Disassembly Listing for Basic_UART_INTs
Generated From:
C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/dist/default/production/Basic_UART_INTs_SPI.X.production.elf
Jul 1, 2021 4:37:06 PM

---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/utils.c  ----
1:             #include "mcc_generated_files/mcc.h"
2:             #include "my_defs.h"
3:             
4:             
5:             //XC8 inline __delay_ms function only allows for maximum delay of about 4s at 64MHz ...
6:             void Delay_ms(uint16_t ms) {
7:              uint16_t i;
8:              
9:                 for(i=0;i<ms;i++)
2232  6A0D     CLRF i, ACCESS
2234  6A0E     CLRF product, ACCESS
2236  D00A     BRA 0x224C
10:                    __delay_ms(1);
2238  0E15     MOVLW 0x15
223A  6E0C     MOVWF status, ACCESS
223C  0EC6     MOVLW 0xC6
223E  2EE8     DECFSZ 0xFE8, F, ACCESS
2240  D7FE     BRA 0x223E
2242  2E0C     DECFSZ status, F, ACCESS
2244  D7FC     BRA 0x223E
2246  D000     BRA 0x2248
2248  4A0D     INFSNZ i, F, ACCESS
224A  2A0E     INCF product, F, ACCESS
224C  500A     MOVF dividend, W, ACCESS
224E  5C0D     SUBWF i, W, ACCESS
2250  500B     MOVF blue, W, ACCESS
2252  580E     SUBWFB product, W, ACCESS
2254  E3F1     BNC 0x2238
11:            }
2256  0012     RETURN 0
12:            
13:            void Delay_us(uint16_t us) {
14:             uint16_t i;
15:             
16:                for(i=0;i<us;i++)
17:                    __delay_us(1);
18:            }
19:            
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/sound.c  ----
1:             
2:             #include <xc.h>
3:             #include "my_defs.h"
4:             
5:             
6:             void Teste_sound(void) {
7:                 for(;;)
8:                     for(uint8_t i=20;i<255;i++) {
9:                         Sound(i, ON);
10:                        Delay_ms(100);
11:                    }
12:            }
13:            
14:            void Beep(uint16_t duration) {
15:            
16:                Sound(35, ON);
22BE  0E01     MOVLW 0x1
22C0  6E0C     MOVWF status, ACCESS
22C2  0E23     MOVLW 0x23
22C4  EC06     CALL 0x220C, 0
22C6  F011     NOP
17:                Delay_ms(duration);
22C8  C00F     MOVFF duration, dividend
22CA  F00A     NOP
22CC  C010     MOVFF j, blue
22CE  F00B     NOP
22D0  EC19     CALL 0x2232, 0
22D2  F011     NOP
18:                Sound(35,OFF);
22D4  6A0C     CLRF status, ACCESS
22D6  0E23     MOVLW 0x23
22D8  EF06     GOTO 0x220C
22DA  F011     NOP
19:            }
20:            
21:            
22:            void Sound(uint8_t freq, uint8_t status) {
220C  6E0D     MOVWF i, ACCESS
23:                PR2=50;
220E  0E32     MOVLW 0x32
2210  6EAB     MOVWF 0xFAB, ACCESS
24:                //50 more or less 5KHZ
25:                if (status==ON) 
2212  040C     DECF status, W, ACCESS
2214  E106     BNZ 0x2222
26:                    PWM1_LoadDutyValue(0x0063); //50%
2216  6A0B     CLRF blue, ACCESS
2218  0E63     MOVLW 0x63
221A  6E0A     MOVWF dividend, ACCESS
221C  EC3E     CALL 0x227C, 0
221E  F011     NOP
2220  D004     BRA 0x222A
27:                else 
28:                    PWM1_LoadDutyValue(0x0000); //0%
2222  6A0B     CLRF blue, ACCESS
2224  6A0A     CLRF dividend, ACCESS
2226  EC3E     CALL 0x227C, 0
2228  F011     NOP
29:                 
30:                PR2=freq;
222C  F037     NOP
222E  FFAB     NOP
31:             }
2230  0012     RETURN 0
32:            
33:            void Beep_reset(void) {
34:                Beep(100);
22A0  D80A     RCALL __end_of_Beep_reset
22A2  EC5F     CALL 0x22BE, 0
22A4  F011     NOP
35:                Delay_ms(50);
22A6  6A0B     CLRF blue, ACCESS
22A8  0E32     MOVLW 0x32
22AA  6E0A     MOVWF dividend, ACCESS
22AC  EC19     CALL 0x2232, 0
22AE  F011     NOP
22B0  D802     RCALL __end_of_Beep_reset
36:                Beep(100);
22B2  EF5F     GOTO 0x22BE
22B4  F011     NOP
37:            }   
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/uart2.c
1:             /**
2:               UART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart2.h"
52:            #include "..\my_defs.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            
58:            /**
59:              Section: Global Variables
60:            */
61:            
62:            static volatile uint8_t uart2TxHead = 0;
63:            static volatile uint8_t uart2TxTail = 0;
64:            static volatile uint8_t uart2TxBuffer[UART2_TX_BUFFER_SIZE];
65:            volatile uint8_t uart2TxBufferRemaining;
66:            
67:            static volatile uint8_t uart2RxHead = 0;
68:            static volatile uint8_t uart2RxTail = 0;
69:            static volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
70:            static volatile uart2_status_t uart2RxStatusBuffer[UART2_RX_BUFFER_SIZE];
71:            volatile uint8_t uart2RxCount;
72:            static volatile uart2_status_t uart2RxLastError;
73:            
74:            volatile uint8_t new_message_in_rx2_buffer;
75:            
76:            /**
77:              Section: UART2 APIs
78:            */
79:            void (*UART2_FramingErrorHandler)(void);
80:            void (*UART2_OverrunErrorHandler)(void);
81:            void (*UART2_ErrorHandler)(void);
82:            
83:            void UART2_DefaultFramingErrorHandler(void);
84:            void UART2_DefaultOverrunErrorHandler(void);
85:            void UART2_DefaultErrorHandler(void);
86:            
87:            void UART2_Initialize(void)
88:            {
89:                // Disable interrupts before changing states
90:                PIE7bits.U2RXIE = 0;
1B64  0139     MOVLB 0x39
1B66  9997     BCF 0x97, 4, BANKED
91:                UART2_SetRxInterruptHandler(UART2_Receive_ISR);
1B68  0E66     MOVLW 0x66
1B6A  6E0A     MOVWF dividend, ACCESS
1B6C  0E1C     MOVLW 0x1C
1B6E  6E0B     MOVWF blue, ACCESS
1B70  ECF9     CALL 0x23F2, 0
1B72  F011     NOP
92:                PIE7bits.U2TXIE = 0;
1B74  9B97     BCF 0x97, 5, BANKED
93:                UART2_SetTxInterruptHandler(UART2_Transmit_ISR);
1B76  0EC8     MOVLW 0xC8
1B78  6E0A     MOVWF dividend, ACCESS
1B7A  0E20     MOVLW 0x20
1B7C  6E0B     MOVWF blue, ACCESS
1B7E  ECF4     CALL 0x23E8, 0
1B80  F011     NOP
94:            
95:                // Set the UART2 module to the options selected in the user interface.
96:            
97:                // P1L 0; 
98:                U2P1L = 0x00;
1B82  013D     MOVLB 0x3D
1B84  6BD4     CLRF UART1_FramingErrorHandler, BANKED
99:            
100:               // P1H 0; 
101:               U2P1H = 0x00;
1B86  6BD5     CLRF 0xD5, BANKED
102:           
103:               // P2L 0; 
104:               U2P2L = 0x00;
1B88  6BD6     CLRF UART1_TxInterruptHandler, BANKED
105:           
106:               // P2H 0; 
107:               U2P2H = 0x00;
1B8A  6BD7     CLRF 0xD7, BANKED
108:           
109:               // P3L 0; 
110:               U2P3L = 0x00;
1B8C  6BD8     CLRF UART1_RxInterruptHandler, BANKED
111:           
112:               // P3H 0; 
113:               U2P3H = 0x00;
1B8E  6BD9     CLRF 0xD9, BANKED
114:           
115:               // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:               U2CON0 = 0xB0;
1B90  0EB0     MOVLW 0xB0
1B92  6FDA     MOVWF UART2_TxInterruptHandler, BANKED
117:           
118:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:               U2CON1 = 0x80;
1B94  0E80     MOVLW 0x80
1B96  6FDB     MOVWF 0xDB, BANKED
120:           
121:               // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:               U2CON2 = 0x00;
1B98  6BDC     CLRF UART2_RxInterruptHandler, BANKED
123:           
124:               // BRGL 138; 
125:               U2BRGL = 0x8A;
1B9A  0E8A     MOVLW 0x8A
1B9C  6FDD     MOVWF 0xDD, BANKED
126:           
127:               // BRGH 0; 
128:               U2BRGH = 0x00;
1B9E  6BDE     CLRF uart2RxTail, BANKED
129:           
130:               // STPMD in middle of first Stop bit; TXWRE No error; 
131:               U2FIFO = 0x00;
1BA0  6BDF     CLRF uart2TxBufferRemaining, BANKED
132:           
133:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:               U2UIR = 0x00;
1BA2  6BE0     CLRF uart1RxTail, BANKED
135:           
136:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:               U2ERRIR = 0x00;
1BA4  6BE1     CLRF uart1TxBufferRemaining, BANKED
138:           
139:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:               U2ERRIE = 0x00;
1BA6  6BE2     CLRF __pdataBANK0, BANKED
141:           
142:           
143:               UART2_SetFramingErrorHandler(UART2_DefaultFramingErrorHandler);
1BA8  0E64     MOVLW 0x64
1BAA  6E0A     MOVWF dividend, ACCESS
1BAC  0E24     MOVLW 0x24
1BAE  6E0B     MOVWF blue, ACCESS
1BB0  EC03     CALL 0x2406, 0
1BB2  F012     NOP
144:               UART2_SetOverrunErrorHandler(UART2_DefaultOverrunErrorHandler);
1BB4  0E62     MOVLW 0x62
1BB6  6E0A     MOVWF dividend, ACCESS
1BB8  0E24     MOVLW 0x24
1BBA  6E0B     MOVWF blue, ACCESS
1BBC  ECFE     CALL 0x23FC, 0
1BBE  F011     NOP
145:               UART2_SetErrorHandler(UART2_DefaultErrorHandler);
1BC0  0E56     MOVLW 0x56
1BC2  6E0A     MOVWF dividend, ACCESS
1BC4  0E24     MOVLW 0x24
1BC6  6E0B     MOVWF blue, ACCESS
1BC8  EC08     CALL 0x2410, 0
1BCA  F012     NOP
146:           
147:               uart2RxLastError.status = 0;
1BCC  0100     MOVLB 0x0
1BCE  6B82     CLRF uart2RxLastError, BANKED
148:           
149:               // initializing the driver state
150:               uart2TxHead = 0;
1BD0  6A51     CLRF uart2TxHead, ACCESS
151:               uart2TxTail = 0;
1BD2  6A50     CLRF uart2TxTail, ACCESS
152:               uart2TxBufferRemaining = sizeof(uart2TxBuffer);
1BD4  0E50     MOVLW 0x50
1BD6  6FDF     MOVWF uart2TxBufferRemaining, BANKED
153:               uart2RxHead = 1;
1BD8  0E01     MOVLW 0x1
1BDA  6E54     MOVWF uart2RxHead, ACCESS
154:               uart2RxTail = 1;
1BDC  6FDE     MOVWF uart2RxTail, BANKED
155:               uart2RxCount = 0;
1BDE  6B83     CLRF uart2RxCount, BANKED
156:           
157:               // enable receive interrupt
158:               PIE7bits.U2RXIE = 1;
1BE0  0139     MOVLB 0x39
1BE2  8997     BSF 0x97, 4, BANKED
159:           }
1BE4  0012     RETURN 0
160:           
161:           bool UART2_is_rx_ready(void)
162:           {
163:               return (uart2RxCount ? true : false);
164:           }
165:           
166:           bool UART2_is_tx_ready(void)
167:           {
168:               return (uart2TxBufferRemaining ? true : false);
169:           }
170:           
171:           bool UART2_is_tx_done(void)
172:           {
173:               return U2ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart2_status_t UART2_get_last_status(void){
177:               return uart2RxLastError;
178:           }
179:           
180:           uint8_t UART2_Read(void)
181:           {
182:               uint8_t readValue  = 0;
183:               
184:               while(0 == uart2RxCount)
185:               {
186:               }
187:           
188:               uart2RxLastError = uart2RxStatusBuffer[uart2RxTail];
189:           
190:               readValue = uart2RxBuffer[uart2RxTail++];
191:              	if(sizeof(uart2RxBuffer) <= uart2RxTail)
192:               {
193:                   uart2RxTail = 0;
194:               }
195:               PIE7bits.U2RXIE = 0;
196:               uart2RxCount--;
197:               PIE7bits.U2RXIE = 1;
198:           
199:               return readValue;
200:           }
201:           
202:           void UART2_Write(uint8_t txData)
2058  6E0A     MOVWF dividend, ACCESS
203:           {
204:               while(0 == uart2TxBufferRemaining)
205A  0100     MOVLB 0x0
205C  51DF     MOVF uart2TxBufferRemaining, W, BANKED
205E  E0FD     BZ 0x205A
205:               {
206:               }
207:           
208:               if(0 == PIE7bits.U2TXIE)
2060  0139     MOVLB 0x39
2062  BB97     BTFSC 0x97, 5, BANKED
2064  D004     BRA 0x206E
209:               {
210:                   U2TXB = txData;
2068  F02B     NOP
206A  FDD2     NOP
211:               }
206C  D00F     BRA 0x208C
212:               else
213:               {
214:                   PIE7bits.U2TXIE = 0;
206E  9B97     BCF 0x97, 5, BANKED
215:                   uart2TxBuffer[uart2TxHead++] = txData;
2070  0E50     MOVLW 0x50
2072  2451     ADDWF uart2TxHead, W, ACCESS
2074  EC78     CALL 0x20F0, 0
2076  F010     NOP
207A  F02B     NOP
207C  FFDF     NOP
207E  2A51     INCF uart2TxHead, F, ACCESS
216:                   if(sizeof(uart2TxBuffer) <= uart2TxHead)
2080  0E4F     MOVLW 0x4F
2082  6451     CPFSGT uart2TxHead, ACCESS
2084  D001     BRA 0x2088
217:                   {
218:                       uart2TxHead = 0;
2086  6A51     CLRF uart2TxHead, ACCESS
219:                   }
220:                   uart2TxBufferRemaining--;
2088  0100     MOVLB 0x0
208A  07DF     DECF uart2TxBufferRemaining, F, BANKED
221:               }
222:               PIE7bits.U2TXIE = 1;
208C  0139     MOVLB 0x39
208E  8B97     BSF 0x97, 5, BANKED
223:           }
2090  0012     RETURN 0
224:           
225:           
226:           
227:           
228:           
229:           void UART2_Transmit_ISR(void)
230:           {
231:               // use this default transmit interrupt handler code
232:               if(sizeof(uart2TxBuffer) > uart2TxBufferRemaining)
20C8  0E50     MOVLW 0x50
20CA  61DF     CPFSLT uart2TxBufferRemaining, BANKED
20CC  D00E     BRA 0x20EA
233:               {
234:                   U2TXB = uart2TxBuffer[uart2TxTail++];
20CE  0E50     MOVLW 0x50
20D0  2450     ADDWF uart2TxTail, W, ACCESS
20D2  D80E     RCALL PL52
20D4  50DF     MOVF 0xFDF, W, ACCESS
20D6  013D     MOVLB 0x3D
20D8  6FD2     MOVWF UART1_OverrunErrorHandler, BANKED
20DA  2A50     INCF uart2TxTail, F, ACCESS
235:                  if(sizeof(uart2TxBuffer) <= uart2TxTail)
20DC  0E4F     MOVLW 0x4F
20DE  6450     CPFSGT uart2TxTail, ACCESS
20E0  D001     BRA 0x20E4
236:                   {
237:                       uart2TxTail = 0;
20E2  6A50     CLRF uart2TxTail, ACCESS
238:                   }
239:                   uart2TxBufferRemaining++;
20E4  0100     MOVLB 0x0
20E6  2BDF     INCF uart2TxBufferRemaining, F, BANKED
240:               }
20E8  0012     RETURN 0
241:               else
242:               {
243:                   PIE7bits.U2TXIE = 0;
20EA  0139     MOVLB 0x39
20EC  9B97     BCF 0x97, 5, BANKED
244:               }
245:               
246:               // or set custom function using UART2_SetTxInterruptHandler()
247:           }
20EE  0012     RETURN 0
248:           
249:           void UART2_Receive_ISR(void)
250:           {
251:               // use this default receive interrupt handler code
252:               uart2RxStatusBuffer[uart2RxHead].status = 0;
1C66  D837     RCALL __end_of_UART2_Receive_ISR
1C68  ECAE     CALL 0x1B5C, 0
1C6A  F00D     NOP
253:           
254:               if(U2ERRIRbits.FERIF){
1C6C  A7E1     BTFSS uart1TxBufferRemaining, 3, BANKED
1C6E  D00F     BRA 0x1C8E
1C70  D832     RCALL __end_of_UART2_Receive_ISR
255:                   uart2RxStatusBuffer[uart2RxHead].ferr = 1;
1C72  0102     MOVLB 0x2
1C74  82DF     BSF 0xFDF, 1, ACCESS
256:                   UART2_FramingErrorHandler();
1C76  D801     RCALL 0x1C7A
1C78  D00A     BRA 0x1C8E
1C7A  0005     PUSH
1C7C  6EFA     MOVWF 0xFFA, ACCESS
1C7E  0100     MOVLB 0x0
1C80  51CE     MOVF UART2_FramingErrorHandler, W, BANKED
1C82  6EFD     MOVWF 0xFFD, ACCESS
1C84  51CF     MOVF 0xCF, W, BANKED
1C86  6EFE     MOVWF 0xFFE, ACCESS
1C88  6AFF     CLRF 0xFFF, ACCESS
1C8A  50FA     MOVF 0xFFA, W, ACCESS
1C8C  0012     RETURN 0
257:               }
258:               
259:               if(U2ERRIRbits.RXFOIF || new_message_in_rx2_buffer){
1C8E  013D     MOVLB 0x3D
1C90  B3E1     BTFSC uart1TxBufferRemaining, 1, BANKED
1C92  D003     BRA 0x1C9A
1C94  0100     MOVLB 0x0
1C96  5181     MOVF new_message_in_rx2_buffer, W, BANKED
1C98  E00F     BZ 0x1CB8
1C9A  D81D     RCALL __end_of_UART2_Receive_ISR
260:                   uart2RxStatusBuffer[uart2RxHead].oerr = 1;
1C9C  0102     MOVLB 0x2
1C9E  84DF     BSF 0xFDF, 2, ACCESS
261:                   UART2_OverrunErrorHandler();
1CA0  D801     RCALL 0x1CA4
1CA2  D00A     BRA 0x1CB8
1CA4  0005     PUSH
1CA6  6EFA     MOVWF 0xFFA, ACCESS
1CA8  0100     MOVLB 0x0
1CAA  51CC     MOVF UART2_OverrunErrorHandler, W, BANKED
1CAC  6EFD     MOVWF 0xFFD, ACCESS
1CAE  51CD     MOVF 0xCD, W, BANKED
1CB0  6EFE     MOVWF 0xFFE, ACCESS
1CB2  6AFF     CLRF 0xFFF, ACCESS
1CB4  50FA     MOVF 0xFFA, W, ACCESS
1CB6  0012     RETURN 0
1CB8  D80E     RCALL __end_of_UART2_Receive_ISR
262:               }
263:               
264:               if(uart2RxStatusBuffer[uart2RxHead].status){
1CBA  50DF     MOVF 0xFDF, W, ACCESS
1CBC  E102     BNZ 0x1CC2
1CBE  EFAB     GOTO 0x1F56
1CC0  F00F     NOP
265:                   UART2_ErrorHandler();
1CC2  0005     PUSH
1CC4  6EFA     MOVWF 0xFFA, ACCESS
1CC6  0100     MOVLB 0x0
1CC8  51CA     MOVF UART2_ErrorHandler, W, BANKED
1CCA  6EFD     MOVWF 0xFFD, ACCESS
1CCC  51CB     MOVF 0xCB, W, BANKED
1CCE  6EFE     MOVWF 0xFFE, ACCESS
1CD0  6AFF     CLRF 0xFFF, ACCESS
1CD2  50FA     MOVF 0xFFA, W, ACCESS
1CD4  0012     RETURN 0
266:               } else {
267:                   UART2_RxDataHandler();
268:               }
269:           
270:               // or set custom function using UART2_SetRxInterruptHandler()
271:           }
272:           
273:           //void UART2_RxDataHandler(void){
274:           //    // use this default receive interrupt handler code
275:           //    uart2RxBuffer[uart2RxHead++] = U2RXB;
276:           //    if(sizeof(uart2RxBuffer) <= uart2RxHead)
277:           //    {
278:           //        uart2RxHead = 0;
279:           //    }
280:           //    uart2RxCount++;
281:           //}
282:           
283:           void UART2_RxDataHandler(void){
284:               // use this default receive interrupt handler code
285:               uart2RxBuffer[uart2RxHead] = U2RXB;
1F56  D81E     RCALL PL38
1F5A  F743     NOP
1F5C  FFDF     NOP
1F5E  D81A     RCALL PL38
286:               
287:               if((uart2RxBuffer[uart2RxHead]=='\n' && uart2RxBuffer[uart2RxHead-1]=='\r') || (uart2RxHead == sizeof(uart2RxBuffer)-4) ) {
1F60  0E0A     MOVLW 0xA
1F62  18DE     XORWF 0xFDE, W, ACCESS
1F64  E109     BNZ 0x1F78
1F66  0EFF     MOVLW 0xFF
1F68  2454     ADDWF uart2RxHead, W, ACCESS
1F6A  6ED9     MOVWF 0xFD9, ACCESS
1F6C  6ADA     CLRF 0xFDA, ACCESS
1F6E  0E00     MOVLW 0x0
1F70  22DA     ADDWFC 0xFDA, F, ACCESS
1F72  0E0D     MOVLW 0xD
1F74  18DE     XORWF 0xFDE, W, ACCESS
1F76  E003     BZ 0x1F7E
1F78  0E4C     MOVLW 0x4C
1F7A  1854     XORWF uart2RxHead, W, ACCESS
1F7C  E109     BNZ 0x1F90
288:                   uart2RxBuffer[uart2RxHead+1]='\0';
1F7E  0E01     MOVLW 0x1
1F80  2454     ADDWF uart2RxHead, W, ACCESS
1F82  6ED9     MOVWF 0xFD9, ACCESS
1F84  6ADA     CLRF 0xFDA, ACCESS
1F86  0E01     MOVLW 0x1
1F88  ECA7     CALL 0x1F4E, 0
1F8A  F00F     NOP
289:                   new_message_in_rx2_buffer=1;
1F8C  6F81     MOVWF new_message_in_rx2_buffer, BANKED
290:                   uart2RxHead=0;
1F8E  6A54     CLRF uart2RxHead, ACCESS
291:               }    
292:               uart2RxHead++;
1F90  2A54     INCF uart2RxHead, F, ACCESS
293:           }
1F92  0012     RETURN 0
294:           
295:           
296:           void UART2_DefaultFramingErrorHandler(void){}
2464  0012     RETURN 0
297:           
298:           void UART2_DefaultOverrunErrorHandler(void){}
2462  0012     RETURN 0
299:           
300:           void UART2_DefaultErrorHandler(void){
301:               UART2_RxDataHandler();
2456  EFAB     GOTO 0x1F56
2458  F00F     NOP
302:           }
303:           
304:           void UART2_SetFramingErrorHandler(void (* interruptHandler)(void)){
305:               UART2_FramingErrorHandler = interruptHandler;
2406  C00A     MOVFF dividend, UART2_FramingErrorHandler
2408  F0CE     NOP
240A  C00B     MOVFF blue, 0xCF
240C  F0CF     NOP
306:           }
240E  0012     RETURN 0
307:           
308:           void UART2_SetOverrunErrorHandler(void (* interruptHandler)(void)){
309:               UART2_OverrunErrorHandler = interruptHandler;
23FC  C00A     MOVFF dividend, UART2_OverrunErrorHandler
23FE  F0CC     NOP
2400  C00B     MOVFF blue, 0xCD
2402  F0CD     NOP
310:           }
2404  0012     RETURN 0
311:           
312:           void UART2_SetErrorHandler(void (* interruptHandler)(void)){
313:               UART2_ErrorHandler = interruptHandler;
2410  C00A     MOVFF dividend, UART2_ErrorHandler
2412  F0CA     NOP
2414  C00B     MOVFF blue, 0xCB
2416  F0CB     NOP
314:           }
2418  0012     RETURN 0
315:           
316:           
317:           
318:           void UART2_SetRxInterruptHandler(void (* InterruptHandler)(void)){
319:               UART2_RxInterruptHandler = InterruptHandler;
23F2  C00A     MOVFF dividend, UART2_RxInterruptHandler
23F4  F0DC     NOP
23F6  C00B     MOVFF blue, 0xDD
23F8  F0DD     NOP
320:           }
23FA  0012     RETURN 0
321:           
322:           void UART2_SetTxInterruptHandler(void (* InterruptHandler)(void)){
323:               UART2_TxInterruptHandler = InterruptHandler;
23E8  C00A     MOVFF dividend, UART2_TxInterruptHandler
23EA  F0DA     NOP
23EC  C00B     MOVFF blue, 0xDB
23EE  F0DB     NOP
324:           }
23F0  0012     RETURN 0
325:           
326:           
327:           /**
328:             End of File
329:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/uart1.c
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "..\my_defs.h"
53:            /**
54:              Section: Macro Declarations
55:            */
56:            
57:            
58:            /**
59:              Section: Global Variables
60:            */
61:            
62:            static volatile uint8_t uart1TxHead = 0;
63:            static volatile uint8_t uart1TxTail = 0;
64:            static volatile uint8_t uart1TxBuffer[UART1_TX_BUFFER_SIZE];
65:            volatile uint8_t uart1TxBufferRemaining;
66:            
67:            static volatile uint8_t uart1RxHead = 0;
68:            static volatile uint8_t uart1RxTail = 0;
69:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
70:            static volatile uart1_status_t uart1RxStatusBuffer[UART1_RX_BUFFER_SIZE];
71:            volatile uint8_t uart1RxCount;
72:            static volatile uart1_status_t uart1RxLastError;
73:            
74:            volatile uint8_t new_message_in_rx1_buffer=0;
75:            
76:            /**
77:              Section: UART1 APIs
78:            */
79:            void (*UART1_FramingErrorHandler)(void);
80:            void (*UART1_OverrunErrorHandler)(void);
81:            void (*UART1_ErrorHandler)(void);
82:            
83:            void UART1_DefaultFramingErrorHandler(void);
84:            void UART1_DefaultOverrunErrorHandler(void);
85:            void UART1_DefaultErrorHandler(void);
86:            
87:            void UART1_Initialize(void)
88:            {
89:                // Disable interrupts before changing states
90:                PIE3bits.U1RXIE = 0;
1BE6  9793     BCF 0x93, 3, BANKED
91:                UART1_SetRxInterruptHandler(UART1_Receive_ISR);
1BE8  0EE0     MOVLW 0xE0
1BEA  6E0A     MOVWF dividend, ACCESS
1BEC  0E1A     MOVLW 0x1A
1BEE  6E0B     MOVWF blue, ACCESS
1BF0  EC12     CALL 0x2424, 0
1BF2  F012     NOP
92:                PIE3bits.U1TXIE = 0;
1BF4  9993     BCF 0x93, 4, BANKED
93:                UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
1BF6  0EFA     MOVLW 0xFA
1BF8  6E0A     MOVWF dividend, ACCESS
1BFA  0E20     MOVLW 0x20
1BFC  6E0B     MOVWF blue, ACCESS
1BFE  EC0D     CALL 0x241A, 0
1C00  F012     NOP
94:            
95:                // Set the UART1 module to the options selected in the user interface.
96:            
97:                // P1L 0; 
98:                U1P1L = 0x00;
1C02  013D     MOVLB 0x3D
1C04  6BEC     CLRF putch_uartfunction_ptr, BANKED
99:            
100:               // P1H 0; 
101:               U1P1H = 0x00;
1C06  6BED     CLRF 0xED, BANKED
102:           
103:               // P2L 0; 
104:               U1P2L = 0x00;
1C08  6BEE     CLRF led_tempo0, BANKED
105:           
106:               // P2H 0; 
107:               U1P2H = 0x00;
1C0A  6BEF     CLRF 0xEF, BANKED
108:           
109:               // P3L 0; 
110:               U1P3L = 0x00;
1C0C  6BF0     CLRF led_tempo1, BANKED
111:           
112:               // P3H 0; 
113:               U1P3H = 0x00;
1C0E  6BF1     CLRF 0xF1, BANKED
114:           
115:               // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:               U1CON0 = 0xB0;
1C10  0EB0     MOVLW 0xB0
1C12  6FF2     MOVWF 0xF2, BANKED
117:           
118:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:               U1CON1 = 0x80;
1C14  0E80     MOVLW 0x80
1C16  6FF3     MOVWF 0xF3, BANKED
120:           
121:               // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:               U1CON2 = 0x00;
1C18  6BF4     CLRF 0xF4, BANKED
123:           
124:               // BRGL 138; 
125:               U1BRGL = 0x8A;
1C1A  0E8A     MOVLW 0x8A
1C1C  6FF5     MOVWF 0xF5, BANKED
126:           
127:               // BRGH 0; 
128:               U1BRGH = 0x00;
1C1E  6BF6     CLRF 0xF6, BANKED
129:           
130:               // STPMD in middle of first Stop bit; TXWRE No error; 
131:               U1FIFO = 0x00;
1C20  6BF7     CLRF 0xF7, BANKED
132:           
133:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:               U1UIR = 0x00;
1C22  6BF8     CLRF 0xF8, BANKED
135:           
136:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:               U1ERRIR = 0x00;
1C24  6BF9     CLRF 0xF9, BANKED
138:           
139:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:               U1ERRIE = 0x00;
1C26  6BFA     CLRF 0xFA, BANKED
141:           
142:           
143:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
1C28  0E68     MOVLW 0x68
1C2A  6E0A     MOVWF dividend, ACCESS
1C2C  0E24     MOVLW 0x24
1C2E  6E0B     MOVWF blue, ACCESS
1C30  EC1C     CALL 0x2438, 0
1C32  F012     NOP
144:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
1C34  0E66     MOVLW 0x66
1C36  6E0A     MOVWF dividend, ACCESS
1C38  0E24     MOVLW 0x24
1C3A  6E0B     MOVWF blue, ACCESS
1C3C  EC17     CALL 0x242E, 0
1C3E  F012     NOP
145:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
1C40  0E5A     MOVLW 0x5A
1C42  6E0A     MOVWF dividend, ACCESS
1C44  0E24     MOVLW 0x24
1C46  6E0B     MOVWF blue, ACCESS
1C48  EC21     CALL 0x2442, 0
1C4A  F012     NOP
146:           
147:               uart1RxLastError.status = 0;
1C4C  0100     MOVLB 0x0
1C4E  6B85     CLRF uart1RxLastError, BANKED
148:           
149:               // initializing the driver state
150:               uart1TxHead = 0;
1C50  6A53     CLRF uart1TxHead, ACCESS
151:               uart1TxTail = 0;
1C52  6A52     CLRF uart1TxTail, ACCESS
152:               uart1TxBufferRemaining = sizeof(uart1TxBuffer);
1C54  0E50     MOVLW 0x50
1C56  6FE1     MOVWF uart1TxBufferRemaining, BANKED
153:               uart1RxHead = 1;
1C58  0E01     MOVLW 0x1
1C5A  6E55     MOVWF uart1RxHead, ACCESS
154:               uart1RxTail = 1;
1C5C  6FE0     MOVWF uart1RxTail, BANKED
155:               uart1RxCount = 0;
1C5E  6B86     CLRF uart1RxCount, BANKED
156:           
157:               // enable receive interrupt
158:               PIE3bits.U1RXIE = 1;
1C60  0139     MOVLB 0x39
1C62  8793     BSF 0x93, 3, BANKED
159:           }
1C64  0012     RETURN 0
160:           
161:           bool UART1_is_rx_ready(void)
162:           {
163:               return (uart1RxCount ? true : false);
164:           }
165:           
166:           bool UART1_is_tx_ready(void)
167:           {
168:               return (uart1TxBufferRemaining ? true : false);
169:           }
170:           
171:           bool UART1_is_tx_done(void)
172:           {
173:               return U1ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart1_status_t UART1_get_last_status(void){
177:               return uart1RxLastError;
178:           }
179:           
180:           uint8_t UART1_Read(void)
181:           {
182:               uint8_t readValue  = 0;
183:               
184:               while(0 == uart1RxCount)
185:               {
186:               }
187:           
188:               uart1RxLastError = uart1RxStatusBuffer[uart1RxTail];
189:           
190:               readValue = uart1RxBuffer[uart1RxTail++];
191:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
192:               {
193:                   uart1RxTail = 0;
194:               }
195:               PIE3bits.U1RXIE = 0;
196:               uart1RxCount--;
197:               PIE3bits.U1RXIE = 1;
198:           
199:               return readValue;
200:           }
201:           
202:           void UART1_Write(uint8_t txData)
201E  6E0A     MOVWF dividend, ACCESS
203:           {
204:               while(0 == uart1TxBufferRemaining)
2020  0100     MOVLB 0x0
2022  51E1     MOVF uart1TxBufferRemaining, W, BANKED
2024  E0FD     BZ 0x2020
205:               {
206:               }
207:           
208:               if(0 == PIE3bits.U1TXIE)
2026  0139     MOVLB 0x39
2028  B993     BTFSC 0x93, 4, BANKED
202A  D004     BRA 0x2034
209:               {
210:                   U1TXB = txData;
202E  F02B     NOP
2030  FDEA     NOP
211:               }
2032  D00F     BRA 0x2052
212:               else
213:               {
214:                   PIE3bits.U1TXIE = 0;
2034  9993     BCF 0x93, 4, BANKED
215:                   uart1TxBuffer[uart1TxHead++] = txData;
2036  0EA0     MOVLW 0xA0
2038  2453     ADDWF uart1TxHead, W, ACCESS
203A  EC91     CALL 0x2122, 0
203C  F010     NOP
2040  F02B     NOP
2042  FFDF     NOP
2044  2A53     INCF uart1TxHead, F, ACCESS
216:                   if(sizeof(uart1TxBuffer) <= uart1TxHead)
2046  0E4F     MOVLW 0x4F
2048  6453     CPFSGT uart1TxHead, ACCESS
204A  D001     BRA 0x204E
217:                   {
218:                       uart1TxHead = 0;
204C  6A53     CLRF uart1TxHead, ACCESS
219:                   }
220:                   uart1TxBufferRemaining--;
204E  0100     MOVLB 0x0
2050  07E1     DECF uart1TxBufferRemaining, F, BANKED
221:               }
222:               PIE3bits.U1TXIE = 1;
2052  0139     MOVLB 0x39
2054  8993     BSF 0x93, 4, BANKED
223:           }
2056  0012     RETURN 0
224:           
225:           char getch(void)
226:           {
227:               return UART1_Read();
228:           }
229:           
230:           //void putch(char txData)
231:           //{
232:           //    UART1_Write(txData);
233:           //}
234:           
235:           
236:           
237:           
238:           
239:           void UART1_Transmit_ISR(void)
240:           {
241:               // use this default transmit interrupt handler code
242:               if(sizeof(uart1TxBuffer) > uart1TxBufferRemaining)
20FA  0E50     MOVLW 0x50
20FC  61E1     CPFSLT uart1TxBufferRemaining, BANKED
20FE  D00E     BRA 0x211C
243:               {
244:                   U1TXB = uart1TxBuffer[uart1TxTail++];
2100  0EA0     MOVLW 0xA0
2102  2452     ADDWF uart1TxTail, W, ACCESS
2104  D80E     RCALL __end_of_UART1_Transmit_ISR
2106  50DF     MOVF 0xFDF, W, ACCESS
2108  013D     MOVLB 0x3D
210A  6FEA     MOVWF 0xEA, BANKED
210C  2A52     INCF uart1TxTail, F, ACCESS
245:                  if(sizeof(uart1TxBuffer) <= uart1TxTail)
210E  0E4F     MOVLW 0x4F
2110  6452     CPFSGT uart1TxTail, ACCESS
2112  D001     BRA 0x2116
246:                   {
247:                       uart1TxTail = 0;
2114  6A52     CLRF uart1TxTail, ACCESS
248:                   }
249:                   uart1TxBufferRemaining++;
2116  0100     MOVLB 0x0
2118  2BE1     INCF uart1TxBufferRemaining, F, BANKED
250:               }
211A  0012     RETURN 0
251:               else
252:               {
253:                   PIE3bits.U1TXIE = 0;
211C  0139     MOVLB 0x39
211E  9993     BCF 0x93, 4, BANKED
254:               }
255:               
256:               // or set custom function using UART1_SetTxInterruptHandler()
257:           }
2120  0012     RETURN 0
258:           
259:           void UART1_Receive_ISR(void)
260:           {
261:               // use this default receive interrupt handler code
262:               uart1RxStatusBuffer[uart1RxHead].status = 0;
1AE0  D836     RCALL PL18
1AE2  D83C     RCALL PL62
263:            
264:               if(U1ERRIRbits.FERIF){
1AE4  A7F9     BTFSS 0xF9, 3, BANKED
1AE6  D00F     BRA 0x1B06
1AE8  D832     RCALL PL18
265:                   uart1RxStatusBuffer[uart1RxHead].ferr = 1;
1AEA  0101     MOVLB 0x1
1AEC  82DF     BSF 0xFDF, 1, ACCESS
266:                   UART1_FramingErrorHandler();
1AEE  D801     RCALL 0x1AF2
1AF0  D00A     BRA 0x1B06
1AF2  0005     PUSH
1AF4  6EFA     MOVWF 0xFFA, ACCESS
1AF6  0100     MOVLB 0x0
1AF8  51D4     MOVF UART1_FramingErrorHandler, W, BANKED
1AFA  6EFD     MOVWF 0xFFD, ACCESS
1AFC  51D5     MOVF 0xD5, W, BANKED
1AFE  6EFE     MOVWF 0xFFE, ACCESS
1B00  6AFF     CLRF 0xFFF, ACCESS
1B02  50FA     MOVF 0xFFA, W, ACCESS
1B04  0012     RETURN 0
267:               }
268:               
269:               if(U1ERRIRbits.RXFOIF || new_message_in_rx1_buffer){
1B06  013D     MOVLB 0x3D
1B08  B3F9     BTFSC 0xF9, 1, BANKED
1B0A  D003     BRA 0x1B12
1B0C  0100     MOVLB 0x0
1B0E  5184     MOVF new_message_in_rx1_buffer, W, BANKED
1B10  E00F     BZ 0x1B30
1B12  D81D     RCALL PL18
270:                   uart1RxStatusBuffer[uart1RxHead].oerr = 1;
1B14  0101     MOVLB 0x1
1B16  84DF     BSF 0xFDF, 2, ACCESS
271:                   UART1_OverrunErrorHandler();
1B18  D801     RCALL 0x1B1C
1B1A  D00A     BRA 0x1B30
1B1C  0005     PUSH
1B1E  6EFA     MOVWF 0xFFA, ACCESS
1B20  0100     MOVLB 0x0
1B22  51D2     MOVF UART1_OverrunErrorHandler, W, BANKED
1B24  6EFD     MOVWF 0xFFD, ACCESS
1B26  51D3     MOVF 0xD3, W, BANKED
1B28  6EFE     MOVWF 0xFFE, ACCESS
1B2A  6AFF     CLRF 0xFFF, ACCESS
1B2C  50FA     MOVF 0xFFA, W, ACCESS
1B2E  0012     RETURN 0
1B30  D80E     RCALL PL18
272:               }
273:               
274:               if(uart1RxStatusBuffer[uart1RxHead].status){
1B32  50DF     MOVF 0xFDF, W, ACCESS
1B34  E102     BNZ 0x1B3A
1B36  EF81     GOTO 0x1F02
1B38  F00F     NOP
275:                   UART1_ErrorHandler();
1B3A  0005     PUSH
1B3C  6EFA     MOVWF 0xFFA, ACCESS
1B3E  0100     MOVLB 0x0
1B40  51D0     MOVF UART1_ErrorHandler, W, BANKED
1B42  6EFD     MOVWF 0xFFD, ACCESS
1B44  51D1     MOVF 0xD1, W, BANKED
1B46  6EFE     MOVWF 0xFFE, ACCESS
1B48  6AFF     CLRF 0xFFF, ACCESS
1B4A  50FA     MOVF 0xFFA, W, ACCESS
1B4C  0012     RETURN 0
276:               } else {
277:                   UART1_RxDataHandler();
278:               }
279:           
280:               // or set custom function using UART1_SetRxInterruptHandler()
281:           }
282:           
283:           //void UART1_RxDataHandler(void){
284:           //    // use this default receive interrupt handler code
285:           //    uart1RxBuffer[uart1RxHead++] = U1RXB;
286:           //    if(sizeof(uart1RxBuffer) <= uart1RxHead)
287:           //    {
288:           //        uart1RxHead = 0;
289:           //    }
290:           //    uart1RxCount++;
291:           //}
292:           
293:           
294:           void UART1_RxDataHandler(void){
295:               // use this default receive interrupt handler code
296:                 
297:               uart1RxBuffer[uart1RxHead] = U1RXB;
1F02  D81E     RCALL __end_of_UART1_RxDataHandler
1F06  F7A3     NOP
1F08  FFDF     NOP
1F0A  D81A     RCALL __end_of_UART1_RxDataHandler
298:               
299:               if((uart1RxBuffer[uart1RxHead]=='\n' && uart1RxBuffer[uart1RxHead-1]=='\r') || (uart1RxHead == sizeof(uart1RxBuffer)-4) ) {
1F0C  0E0A     MOVLW 0xA
1F0E  18DE     XORWF 0xFDE, W, ACCESS
1F10  E109     BNZ 0x1F24
1F12  0E9F     MOVLW 0x9F
1F14  2455     ADDWF uart1RxHead, W, ACCESS
1F16  6ED9     MOVWF 0xFD9, ACCESS
1F18  6ADA     CLRF 0xFDA, ACCESS
1F1A  0E01     MOVLW 0x1
1F1C  22DA     ADDWFC 0xFDA, F, ACCESS
1F1E  0E0D     MOVLW 0xD
1F20  18DE     XORWF 0xFDE, W, ACCESS
1F22  E003     BZ 0x1F2A
1F24  0E4C     MOVLW 0x4C
1F26  1855     XORWF uart1RxHead, W, ACCESS
1F28  E109     BNZ 0x1F3C
300:                    IO_RB0_SetHigh();
1F2A  80BB     BSF 0xFBB, 0, ACCESS
301:                   uart1RxBuffer[uart1RxHead+1]='\0';
1F2C  0EA1     MOVLW 0xA1
1F2E  2455     ADDWF uart1RxHead, W, ACCESS
1F30  6ED9     MOVWF 0xFD9, ACCESS
1F32  6ADA     CLRF 0xFDA, ACCESS
1F34  0E01     MOVLW 0x1
1F36  D80B     RCALL PL46
302:                   new_message_in_rx1_buffer=1;
1F38  6F84     MOVWF new_message_in_rx1_buffer, BANKED
303:                   uart1RxHead=0;
1F3A  6A55     CLRF uart1RxHead, ACCESS
304:               }    
305:               uart1RxHead++;
1F3C  2A55     INCF uart1RxHead, F, ACCESS
306:           }
1F3E  0012     RETURN 0
307:           
308:           
309:           void UART1_DefaultFramingErrorHandler(void){}
2468  0012     RETURN 0
310:           
311:           void UART1_DefaultOverrunErrorHandler(void){}
2466  0012     RETURN 0
312:           
313:           void UART1_DefaultErrorHandler(void){
314:               UART1_RxDataHandler();
245A  EF81     GOTO 0x1F02
245C  F00F     NOP
315:           }
316:           
317:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
318:               UART1_FramingErrorHandler = interruptHandler;
2438  C00A     MOVFF dividend, UART1_FramingErrorHandler
243A  F0D4     NOP
243C  C00B     MOVFF blue, 0xD5
243E  F0D5     NOP
319:           }
2440  0012     RETURN 0
320:           
321:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
322:               UART1_OverrunErrorHandler = interruptHandler;
242E  C00A     MOVFF dividend, UART1_OverrunErrorHandler
2430  F0D2     NOP
2432  C00B     MOVFF blue, 0xD3
2434  F0D3     NOP
323:           }
2436  0012     RETURN 0
324:           
325:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
326:               UART1_ErrorHandler = interruptHandler;
2442  C00A     MOVFF dividend, UART1_ErrorHandler
2444  F0D0     NOP
2446  C00B     MOVFF blue, 0xD1
2448  F0D1     NOP
327:           }
244A  0012     RETURN 0
328:           
329:           
330:           
331:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
332:               UART1_RxInterruptHandler = InterruptHandler;
2424  C00A     MOVFF dividend, UART1_RxInterruptHandler
2426  F0D8     NOP
2428  C00B     MOVFF blue, 0xD9
242A  F0D9     NOP
333:           }
242C  0012     RETURN 0
334:           
335:           void UART1_SetTxInterruptHandler(void (* InterruptHandler)(void)){
336:               UART1_TxInterruptHandler = InterruptHandler;
241A  C00A     MOVFF dividend, UART1_TxInterruptHandler
241C  F0D6     NOP
241E  C00B     MOVFF blue, 0xD7
2420  F0D7     NOP
337:           }
2422  0012     RETURN 0
338:           
339:           
340:           /**
341:             End of File
342:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/tmr2.c
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above 
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            #include "..\my_defs.h"
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
2346  0E01     MOVLW 0x1
2348  6EAE     MOVWF 0xFAE, ACCESS
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
234A  6AAD     CLRF 0xFAD, ACCESS
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
234C  6AAF     CLRF 0xFAF, ACCESS
74:            
75:                // PR2 49; 
76:                T2PR = 0x31;
234E  0E31     MOVLW 0x31
2350  6EAB     MOVWF 0xFAB, ACCESS
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
2352  6AAA     CLRF 0xFAA, ACCESS
80:            
81:                // Clearing IF flag.
82:                PIR4bits.TMR2IF = 0;
2354  0139     MOVLB 0x39
2356  95A4     BCF 0xA4, 2, BANKED
83:            
84:                // T2CKPS 1:64; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0xE0;
2358  0EE0     MOVLW 0xE0
235A  6EAC     MOVWF 0xFAC, ACCESS
86:            }
235C  0CE0     RETLW 0xE0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR4bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR4bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/tmr0.c
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            volatile uint16_t timer0ReloadVal16bit;
59:            
60:            /**
61:              Section: TMR0 APIs
62:            */
63:            
64:            void (*TMR0_InterruptHandler)(void);
65:            
66:            void TMR0_Initialize(void)
67:            {
68:                // Set TMR0 to the options selected in the User Interface
69:            
70:                // T0CS FOSC/4; T0CKPS 1:8; T0ASYNC synchronised; 
71:                T0CON1 = 0x43;
1FE0  0E43     MOVLW 0x43
1FE2  6EB9     MOVWF 0xFB9, ACCESS
72:            
73:                // TMR0H 177; 
74:                TMR0H = 0xB1;
1FE4  0EB1     MOVLW 0xB1
1FE6  6EB7     MOVWF 0xFB7, ACCESS
75:            
76:                // TMR0L 224; 
77:                TMR0L = 0xE0;
1FE8  0EE0     MOVLW 0xE0
1FEA  6EB6     MOVWF 0xFB6, ACCESS
78:            
79:                // Load TMR0 value to the 16-bit reload variable
80:                timer0ReloadVal16bit = (uint16_t)((TMR0H << 8) | TMR0L);
1FEC  50B6     MOVF 0xFB6, W, ACCESS
1FF0  FEDC     NOP
1FF2  F00C     NOP
1FF4  6A0D     CLRF i, ACCESS
1FF6  C00C     MOVFF status, i
1FF8  F00D     NOP
1FFA  6A0C     CLRF status, ACCESS
1FFC  100C     IORWF status, W, ACCESS
1FFE  0100     MOVLB 0x0
2000  6FC8     MOVWF timer0ReloadVal16bit, BANKED
2002  500D     MOVF i, W, ACCESS
2004  6FC9     MOVWF 0xC9, BANKED
81:            
82:                // Clear Interrupt flag before enabling the interrupt
83:                PIR3bits.TMR0IF = 0;
2006  0139     MOVLB 0x39
2008  9FA3     BCF 0xA3, 7, BANKED
84:            
85:                // Enabling TMR0 interrupt.
86:                PIE3bits.TMR0IE = 1;
200A  8F93     BSF 0x93, 7, BANKED
87:            
88:                // Set Default Interrupt Handler
89:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
200C  0E5E     MOVLW 0x5E
200E  6E0A     MOVWF dividend, ACCESS
2010  0E24     MOVLW 0x24
2012  6E0B     MOVWF blue, ACCESS
2014  EC26     CALL 0x244C, 0
2016  F012     NOP
90:            
91:                // T0OUTPS 1:1; T0EN enabled; T016BIT 16-bit; 
92:                T0CON0 = 0x90;
2018  0E90     MOVLW 0x90
201A  6EB8     MOVWF 0xFB8, ACCESS
93:            }
201C  0C90     RETLW 0x90
94:            
95:            void TMR0_StartTimer(void)
96:            {
97:                // Start the Timer by writing to TMR0ON bit
98:                T0CON0bits.T0EN = 1;
99:            }
100:           
101:           void TMR0_StopTimer(void)
102:           {
103:               // Stop the Timer by writing to TMR0ON bit
104:               T0CON0bits.T0EN = 0;
105:           }
106:           
107:           uint16_t TMR0_ReadTimer(void)
108:           {
109:               uint16_t readVal;
110:               uint8_t readValLow;
111:               uint8_t readValHigh;
112:           
113:               readValLow  = TMR0L;
114:               readValHigh = TMR0H;
115:               readVal  = ((uint16_t)readValHigh << 8) + readValLow;
116:           
117:               return readVal;
118:           }
119:           
120:           void TMR0_WriteTimer(uint16_t timerVal)
121:           {
122:               // Write to the Timer0 register
123:               TMR0H = timerVal >> 8;
124:               TMR0L = (uint8_t) timerVal;
125:           }
126:           
127:           void TMR0_Reload(void)
128:           {
129:               // Write to the Timer0 register
130:               TMR0H = timer0ReloadVal16bit >> 8;
131:               TMR0L = (uint8_t) timer0ReloadVal16bit;
132:           }
133:           
134:           void TMR0_ISR(void)
135:           {
136:               // clear the TMR0 interrupt flag
137:               PIR3bits.TMR0IF = 0;
23AC  9FA3     BCF 0xA3, 7, BANKED
138:               // Write to the Timer0 register
139:               TMR0H = timer0ReloadVal16bit >> 8;
23B0  F327     NOP
23B2  FFB7     NOP
140:               TMR0L = (uint8_t) timer0ReloadVal16bit;
23B6  F323     NOP
23B8  FFB6     NOP
141:           
142:               // ticker function call;
143:               // ticker is 1 -> Callback function gets called every time this ISR executes
144:               TMR0_CallBack();
23BA  EF7C     GOTO 0x22F8
23BC  F011     NOP
145:           
146:               // add your TMR0 interrupt custom code
147:           }
148:           
149:           void TMR0_CallBack(void)
150:           {
151:               // Add your custom callback code here
152:           
153:               if(TMR0_InterruptHandler)
22F8  0100     MOVLB 0x0
22FA  51C6     MOVF TMR0_InterruptHandler, W, BANKED
22FC  11C7     IORWF 0xC7, W, BANKED
22FE  B4D8     BTFSC 0xFD8, 2, ACCESS
2300  0012     RETURN 0
154:               {
155:                   TMR0_InterruptHandler();
2302  0005     PUSH
2304  6EFA     MOVWF 0xFFA, ACCESS
2306  51C6     MOVF TMR0_InterruptHandler, W, BANKED
2308  6EFD     MOVWF 0xFFD, ACCESS
230A  51C7     MOVF 0xC7, W, BANKED
230C  6EFE     MOVWF 0xFFE, ACCESS
230E  6AFF     CLRF 0xFFF, ACCESS
2310  50FA     MOVF 0xFFA, W, ACCESS
2312  0012     RETURN 0
156:               }
157:           }
158:           
159:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void)){
160:               TMR0_InterruptHandler = InterruptHandler;
244C  C00A     MOVFF dividend, TMR0_InterruptHandler
244E  F0C6     NOP
2450  C00B     MOVFF blue, 0xC7
2452  F0C7     NOP
161:           }
2454  0012     RETURN 0
162:           
163:           void TMR0_DefaultInterruptHandler(void){
164:               // add your TMR0 interrupt custom code
165:               // or set custom function using TMR0_SetInterruptHandler()
166:           }
245E  0012     RETURN 0
167:           
168:           /**
169:             End of File
170:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/pwm1.c
1:             /**
2:               PWM1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 pwm1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the PWM1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for PWM1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                     MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "pwm1.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            
58:            #define PWM1_INITIALIZE_DUTY_VALUE    99
59:            
60:            /**
61:              Section: PWM Module APIs
62:            */
63:            
64:            void PWM1_Initialize(void)
65:            {
66:                // Set the PWM1 to the options selected in the User Interface
67:            	
68:            	// MODE PWM; EN enabled; FMT right_aligned; 
69:            	CCP1CON = 0x8C;    
235E  0E8C     MOVLW 0x8C
2360  6E7E     MOVWF 0xF7E, ACCESS
70:            	
71:            	// RH 0; 
72:            	CCPR1H = 0x00;    
2362  6A7D     CLRF 0xF7D, ACCESS
73:            	
74:            	// RL 99; 
75:            	CCPR1L = 0x63;    
2364  0E63     MOVLW 0x63
2366  6E7C     MOVWF 0xF7C, ACCESS
76:            
77:            	// Selecting Timer 2
78:            	CCPTMRS0bits.C1TSEL = 0x1;
2368  013F     MOVLB 0x3F
236A  515E     MOVF 0x5E, W, BANKED
236C  0BFC     ANDLW 0xFC
236E  0901     IORLW 0x1
2370  6F5E     MOVWF 0x5E, BANKED
79:                
80:            }
2372  0012     RETURN 0
81:            
82:            void PWM1_LoadDutyValue(uint16_t dutyValue)
83:            {
84:                dutyValue &= 0x03FF;
227C  0E03     MOVLW 0x3
227E  160B     ANDWF blue, F, ACCESS
85:                
86:                // Load duty cycle value
87:                if(CCP1CONbits.FMT)
2280  A87E     BTFSS 0xF7E, 4, ACCESS
2282  D007     BRA PL28
88:                {
89:                    dutyValue <<= 6;
2284  0E06     MOVLW 0x6
2286  90D8     BCF 0xFD8, 0, ACCESS
2288  360A     RLCF dividend, F, ACCESS
228A  360B     RLCF blue, F, ACCESS
228C  2EE8     DECFSZ 0xFE8, F, ACCESS
228E  D7FB     BRA 0x2286
90:                    CCPR1H = (uint8_t) (dutyValue >> 8);
91:                    CCPR1L = (uint8_t) dutyValue;
92:                }
93:                else
2290  D000     BRA PL28
94:                {
95:                    CCPR1H = (uint8_t) (dutyValue >> 8);
96:                    CCPR1L = (uint8_t) dutyValue;
97:                }
98:            }
99:            
100:           bool PWM1_OutputStatusGet(void)
101:           {
102:               // Returns the output status
103:               return(CCP1CONbits.OUT);
104:           }
105:           /**
106:            End of File
107:           */
108:           
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/pin_manager.c
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATA = 0x00;
1EAE  6ABA     CLRF 0xFBA, ACCESS
61:                LATB = 0x00;
1EB0  6ABB     CLRF 0xFBB, ACCESS
62:                LATC = 0x00;
1EB2  6ABC     CLRF 0xFBC, ACCESS
63:            
64:                /**
65:                TRISx registers
66:                */
67:                TRISA = 0xFE;
1EB4  0EFE     MOVLW 0xFE
1EB6  6EC2     MOVWF 0xFC2, ACCESS
68:                TRISB = 0x66;
1EB8  0E66     MOVLW 0x66
1EBA  6EC3     MOVWF 0xFC3, ACCESS
69:                TRISC = 0xFB;
1EBC  0EFB     MOVLW 0xFB
1EBE  6EC4     MOVWF 0xFC4, ACCESS
70:            
71:                /**
72:                ANSELx registers
73:                */
74:                ANSELC = 0x7B;
1EC0  0E7B     MOVLW 0x7B
1EC2  013A     MOVLB 0x3A
1EC4  6F60     MOVWF ws2812_bits, BANKED
75:                ANSELB = 0x5E;
1EC6  0E5E     MOVLW 0x5E
1EC8  6F50     MOVWF uart2TxTail, BANKED
76:                ANSELA = 0xFE;
1ECA  0EFE     MOVLW 0xFE
1ECC  6F40     MOVWF 0x40, BANKED
77:            
78:                /**
79:                WPUx registers
80:                */
81:                WPUE = 0x00;
1ECE  6B81     CLRF new_message_in_rx2_buffer, BANKED
82:                WPUB = 0x00;
1ED0  6B51     CLRF uart2TxHead, BANKED
83:                WPUA = 0x00;
1ED2  6B41     CLRF 0x41, BANKED
84:                WPUC = 0x00;
1ED4  6B61     CLRF 0x61, BANKED
85:            
86:                /**
87:                ODx registers
88:                */
89:                ODCONA = 0x00;
1ED6  6B42     CLRF 0x42, BANKED
90:                ODCONB = 0x00;
1ED8  6B52     CLRF uart1TxTail, BANKED
91:                ODCONC = 0x00;
1EDA  6B62     CLRF 0x62, BANKED
92:            
93:                /**
94:                SLRCONx registers
95:                */
96:                SLRCONA = 0xFF;
1EDC  6943     SETF 0x43, BANKED
97:                SLRCONB = 0xFF;
1EDE  6953     SETF uart1TxHead, BANKED
98:                SLRCONC = 0xFF;
1EE0  6963     SETF 0x63, BANKED
99:            
100:               /**
101:               INLVLx registers
102:               */
103:               INLVLA = 0xFF;
1EE2  6944     SETF 0x44, BANKED
104:               INLVLB = 0xFF;
1EE4  6954     SETF uart2RxHead, BANKED
105:               INLVLC = 0xFF;
1EE6  6964     SETF 0x64, BANKED
106:               INLVLE = 0x08;
1EE8  0E08     MOVLW 0x8
1EEA  6F84     MOVWF new_message_in_rx1_buffer, BANKED
107:           
108:           
109:           
110:           
111:           
112:              
113:               
114:           	
115:               U2RXPPS = 0x17;   //RC7->UART2:RX2;    
1EEC  0E17     MOVLW 0x17
1EEE  6FEA     MOVWF 0xEA, BANKED
116:               RB3PPS = 0x16;   //RB3->UART2:TX2;    
1EF0  0E16     MOVLW 0x16
1EF2  6F0B     MOVWF blue, BANKED
117:               RB4PPS = 0x13;   //RB4->UART1:TX1;    
1EF4  0E13     MOVLW 0x13
1EF6  6F0C     MOVWF status, BANKED
118:               RC2PPS = 0x09;   //RC2->CCP1:CCP1;    
1EF8  0E09     MOVLW 0x9
1EFA  6F12     MOVWF divisor, BANKED
119:               U1RXPPS = 0x0D;   //RB5->UART1:RX1;    
1EFC  0E0D     MOVLW 0xD
1EFE  6FE7     MOVWF 0xE7, BANKED
120:           }
1F00  0C0D     RETLW 0xD
121:             
122:           void PIN_MANAGER_IOC(void)
123:           {   
124:           }
125:           
126:           /**
127:            End of File
128:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/mcc.c
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
2258  ECE7     CALL 0x23CE, 0
225A  F011     NOP
53:                PMD_Initialize();
225C  ECC4     CALL 0x2388, 0
225E  F011     NOP
54:                PIN_MANAGER_Initialize();
2260  EC57     CALL 0x1EAE, 0
2262  F00F     NOP
55:                OSCILLATOR_Initialize();
2264  ECCD     CALL 0x239A, 0
2266  F011     NOP
56:                PWM1_Initialize();
2268  ECAF     CALL 0x235E, 0
226A  F011     NOP
57:                TMR2_Initialize();
226C  ECA3     CALL 0x2346, 0
226E  F011     NOP
58:                TMR0_Initialize();
2270  ECF0     CALL 0x1FE0, 0
2272  F00F     NOP
59:                UART2_Initialize();
2274  ECB2     CALL 0x1B64, 0
2276  F00D     NOP
60:                UART1_Initialize();
2278  EFF3     GOTO 0x1BE6
227A  F00D     NOP
61:            }
62:            
63:            void OSCILLATOR_Initialize(void)
64:            {
65:                // NOSC HFINTOSC; NDIV 1; 
66:                OSCCON1 = 0x60;
239A  0E60     MOVLW 0x60
239C  0139     MOVLB 0x39
239E  6FD9     MOVWF 0xD9, BANKED
67:                // CSWHOLD may proceed; SOSCPWR Low power; 
68:                OSCCON3 = 0x00;
23A0  6BDB     CLRF 0xDB, BANKED
69:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
70:                OSCEN = 0x00;
23A2  6BDD     CLRF 0xDD, BANKED
71:                // HFFRQ 64_MHz; 
72:                OSCFRQ = 0x08;
23A4  0E08     MOVLW 0x8
23A6  6FDF     MOVWF uart2TxBufferRemaining, BANKED
73:                // TUN 0; 
74:                OSCTUNE = 0x00;
23A8  6BDE     CLRF uart2RxTail, BANKED
75:            }
23AA  0012     RETURN 0
76:            
77:            void PMD_Initialize(void)
78:            {
79:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; NVMMD NVM enabled; 
80:                PMD0 = 0x00;
2388  6BC0     CLRF ap, BANKED
81:                // NCO1MD DDS(NCO1) enabled; TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
82:                PMD1 = 0x00;
238A  6BC1     CLRF 0xC1, BANKED
83:                // ZCDMD ZCD enabled; DACMD DAC enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; 
84:                PMD2 = 0x00;
238C  6BC2     CLRF i, BANKED
85:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; CCP4MD CCP4 enabled; CCP3MD CCP3 enabled; PWM6MD PWM6 enabled; PWM5MD PWM5 enabled; PWM8MD PWM8 enabled; PWM7MD PWM7 enabled; 
86:                PMD3 = 0x00;
238E  6BC3     CLRF 0xC3, BANKED
87:                // CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; 
88:                PMD4 = 0x00;
2390  6BC4     CLRF i, BANKED
89:                // U2MD UART2 enabled; U1MD UART1 enabled; SPI1MD SPI1 enabled; I2C2MD I2C2 enabled; I2C1MD I2C1 enabled; 
90:                PMD5 = 0x00;
2392  6BC5     CLRF 0xC5, BANKED
91:                // DSMMD DSM1 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; SMT1MD SMT1 enabled; SMT2MD SMT2 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
92:                PMD6 = 0x00;
2394  6BC6     CLRF TMR0_InterruptHandler, BANKED
93:                // DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; 
94:                PMD7 = 0x00;
2396  6BC7     CLRF 0xC7, BANKED
95:            }
2398  0012     RETURN 0
96:            
97:            
98:            /**
99:             End of File
100:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/mcc_generated_files/interrupt_manager.c
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
19:                    Device            :  PIC18F26K83
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.31 and above or later
23:                    MPLAB 	          :  MPLAB X 5.45
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                // Enable Interrupt Priority Vectors
55:                INTCON0bits.IPEN = 1;
23CE  8AD2     BSF 0xFD2, 5, ACCESS
56:            
57:                // Assign peripheral interrupt priority vectors
58:            
59:                // UTXI - high priority
60:                IPR7bits.U2TXIP = 1;
23D0  0139     MOVLB 0x39
23D2  8B87     BSF dbuf, 5, BANKED
61:            
62:                // URXI - high priority
63:                IPR7bits.U2RXIP = 1;
23D4  8987     BSF dbuf, 4, BANKED
64:            
65:                // UTXI - high priority
66:                IPR3bits.U1TXIP = 1;
23D6  8983     BSF uart2RxCount, 4, BANKED
67:            
68:                // URXI - high priority
69:                IPR3bits.U1RXIP = 1;
23D8  8783     BSF uart2RxCount, 3, BANKED
70:            
71:            
72:                // TMRI - low priority
73:                IPR3bits.TMR0IP = 0;    
23DA  9F83     BCF uart2RxCount, 7, BANKED
74:            
75:            }
23DC  0012     RETURN 0
76:            
77:            void __interrupt() INTERRUPT_InterruptManagerHigh (void)
78:            {
79:               // interrupt handler
80:                if(PIE7bits.U2TXIE == 1 && PIR7bits.U2TXIF == 1)
1D5E  0139     MOVLB 0x39
1D60  BB97     BTFSC 0x97, 5, BANKED
1D62  ABA7     BTFSS __pcstackBANK0, 5, BANKED
1D64  D00C     BRA 0x1D7E
81:                {
82:                    UART2_TxInterruptHandler();
1D66  D801     RCALL 0x1D6A
1D68  0011     RETFIE 1
1D6A  0005     PUSH
1D6C  6EFA     MOVWF 0xFFA, ACCESS
1D6E  0100     MOVLB 0x0
1D70  51DA     MOVF UART2_TxInterruptHandler, W, BANKED
1D72  6EFD     MOVWF 0xFFD, ACCESS
1D74  51DB     MOVF 0xDB, W, BANKED
1D76  6EFE     MOVWF 0xFFE, ACCESS
1D78  6AFF     CLRF 0xFFF, ACCESS
1D7A  50FA     MOVF 0xFFA, W, ACCESS
1D7C  0012     RETURN 0
83:                }
84:                else if(PIE7bits.U2RXIE == 1 && PIR7bits.U2RXIF == 1)
1D7E  B997     BTFSC 0x97, 4, BANKED
1D80  A9A7     BTFSS __pcstackBANK0, 4, BANKED
1D82  D00C     BRA 0x1D9C
85:                {
86:                    UART2_RxInterruptHandler();
1D84  D801     RCALL 0x1D88
1D86  0011     RETFIE 1
1D88  0005     PUSH
1D8A  6EFA     MOVWF 0xFFA, ACCESS
1D8C  0100     MOVLB 0x0
1D8E  51DC     MOVF UART2_RxInterruptHandler, W, BANKED
1D90  6EFD     MOVWF 0xFFD, ACCESS
1D92  51DD     MOVF 0xDD, W, BANKED
1D94  6EFE     MOVWF 0xFFE, ACCESS
1D96  6AFF     CLRF 0xFFF, ACCESS
1D98  50FA     MOVF 0xFFA, W, ACCESS
1D9A  0012     RETURN 0
87:                }
88:                else if(PIE3bits.U1TXIE == 1 && PIR3bits.U1TXIF == 1)
1D9C  B993     BTFSC 0x93, 4, BANKED
1D9E  A9A3     BTFSS 0xA3, 4, BANKED
1DA0  D00C     BRA 0x1DBA
89:                {
90:                    UART1_TxInterruptHandler();
1DA2  D801     RCALL 0x1DA6
1DA4  0011     RETFIE 1
1DA6  0005     PUSH
1DA8  6EFA     MOVWF 0xFFA, ACCESS
1DAA  0100     MOVLB 0x0
1DAC  51D6     MOVF UART1_TxInterruptHandler, W, BANKED
1DAE  6EFD     MOVWF 0xFFD, ACCESS
1DB0  51D7     MOVF 0xD7, W, BANKED
1DB2  6EFE     MOVWF 0xFFE, ACCESS
1DB4  6AFF     CLRF 0xFFF, ACCESS
1DB6  50FA     MOVF 0xFFA, W, ACCESS
1DB8  0012     RETURN 0
91:                }
92:                else if(PIE3bits.U1RXIE == 1 && PIR3bits.U1RXIF == 1)
1DBA  B793     BTFSC 0x93, 3, BANKED
1DBC  A7A3     BTFSS 0xA3, 3, BANKED
1DBE  0011     RETFIE 1
93:                {
94:                    UART1_RxInterruptHandler();
1DC0  D801     RCALL 0x1DC4
1DC2  0011     RETFIE 1
1DC4  0005     PUSH
1DC6  6EFA     MOVWF 0xFFA, ACCESS
1DC8  0100     MOVLB 0x0
1DCA  51D8     MOVF UART1_RxInterruptHandler, W, BANKED
1DCC  6EFD     MOVWF 0xFFD, ACCESS
1DCE  51D9     MOVF 0xD9, W, BANKED
1DD0  6EFE     MOVWF 0xFFE, ACCESS
1DD2  6AFF     CLRF 0xFFF, ACCESS
1DD4  50FA     MOVF 0xFFA, W, ACCESS
1DD6  0012     RETURN 0
95:                }
96:                else
97:                {
98:                    //Unhandled Interrupt
99:                }
100:           }
101:           
102:           void __interrupt(low_priority) INTERRUPT_InterruptManagerLow (void)
2316  FF60     NOP
2318  F009     NOP
103:           {
104:               // interrupt handler
105:               if(PIE3bits.TMR0IE == 1 && PIR3bits.TMR0IF == 1)
231A  0139     MOVLB 0x39
231C  BF93     BTFSC 0x93, 7, BANKED
231E  AFA3     BTFSS 0xA3, 7, BANKED
2320  D002     BRA 0x2326
106:               {
107:                   TMR0_ISR();
2322  ECD6     CALL 0x23AC, 0
2324  F011     NOP
108:               }
109:               else
110:               {
111:                   //Unhandled Interrupt
112:               }
113:           }
2328  F027     NOP
232A  FFD8     NOP
232C  0011     RETFIE 1
114:           /**
115:            End of File
116:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/main.c  -----
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F26K83
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            #include "my_defs.h"
46:            #include <xc.h>
47:            #include <stdbool.h>
48:            #include <stdint.h>
49:            #include <stdio.h>
50:            
51:            
52:            extern volatile uint8_t new_message_in_rx1_buffer;
53:            extern volatile uint8_t new_message_in_rx2_buffer;
54:            extern volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
55:            extern volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
56:            
57:            
58:            
59:            
60:            void (*putch_uartfunction_ptr)(uint8_t)=UART1_Write; //Apontador para funo UARTx_Write pretendida. 
61:            //Tem que se colocar a funo(endereo) pretendido antes de se chamar o printf)
62:            
63:            
64:            
65:            void putch(char txData)
232E  6E0B     MOVWF blue, ACCESS
66:            {
67:                putch_uartfunction_ptr(txData);
2330  0005     PUSH
2332  6EFA     MOVWF 0xFFA, ACCESS
2334  0100     MOVLB 0x0
2336  51EC     MOVF putch_uartfunction_ptr, W, BANKED
2338  6EFD     MOVWF 0xFFD, ACCESS
233A  51ED     MOVF 0xED, W, BANKED
233C  6EFE     MOVWF 0xFFE, ACCESS
233E  6AFF     CLRF 0xFFF, ACCESS
2340  50FA     MOVF 0xFFA, W, ACCESS
2342  500B     MOVF blue, W, ACCESS
2344  0012     RETURN 0
68:                
69:            }
70:            
71:            
72:            
73:            
74:            
75:            void main(void)
76:            {
77:                // Initialize the device
78:                // Initialize the device
79:                SYSTEM_Initialize();
1974  EC2C     CALL 0x2258, 0
1976  F011     NOP
80:                
81:                Beep_reset();
1978  EC50     CALL 0x22A0, 0
197A  F011     NOP
82:                
83:                led_initialize();
197C  ECEF     CALL 0x23DE, 0
197E  F011     NOP
84:              
85:                TMR0_SetInterruptHandler(led_update);
1980  0E60     MOVLW 0x60
1982  6E0A     MOVWF dividend, ACCESS
1984  0E24     MOVLW 0x24
1986  6E0B     MOVWF blue, ACCESS
1988  EC26     CALL 0x244C, 0
198A  F012     NOP
86:            
87:                // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
88:                // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global Interrupts
89:                // Use the following macros to:
90:            
91:                // Enable high priority global interrupts
92:                INTERRUPT_GlobalInterruptHighEnable();
198C  8ED2     BSF 0xFD2, 7, ACCESS
93:            
94:                // Enable low priority global interrupts.
95:                INTERRUPT_GlobalInterruptLowEnable();
198E  8CD2     BSF 0xFD2, 6, ACCESS
96:            
97:                // Disable high priority global interrupts
98:                //INTERRUPT_GlobalInterruptHighDisable();
99:            
100:               // Disable low priority global interrupts.
101:               //INTERRUPT_GlobalInterruptLowDisable();
102:               
103:               basic_test_ws2812_bits();
1990  EC6E     CALL 0x22DC, 0
1992  F011     NOP
104:           
105:             uint16_t i=0;
1994  0100     MOVLB 0x0
1996  6BC2     CLRF i, BANKED
1998  6BC3     CLRF 0xC3, BANKED
106:             
107:               for(;;) {
108:                   putch_uartfunction_ptr=UART1_Write;
199A  D83D     RCALL PL54
109:                   printf("%05d -Siemens UART1 (USB-Serial)\r\n",i);
199C  0E01     MOVLW 0x1
199E  D835     RCALL PL42
19A0  ECBA     CALL 0x2374, 0
19A2  F011     NOP
110:                   //check_for_new_msg_UART1(); //- No funciona porque o buffer de hardware so s dois bytes.  preciso usar interrupes
111:                   
112:                   putch_uartfunction_ptr=UART2_Write;
19A4  D83D     RCALL PL58
113:                   printf("%05d -Siemens UART2 (Bluetooth)\r\n",i++);     
19A6  0E24     MOVLW 0x24
19A8  D830     RCALL PL42
19AA  ECBA     CALL 0x2374, 0
19AC  F011     NOP
19AE  4BC2     INFSNZ i, F, BANKED
19B0  2BC3     INCF 0xC3, F, BANKED
114:                   //check_for_new_msg_UART2();  //- No funciona porque o buffer de hardware so s dois bytes.  preciso usar interrupes
115:                   
116:                   for(uint16_t i=0;i<1000;i++) {
19B2  6BC4     CLRF i, BANKED
19B4  6BC5     CLRF 0xC5, BANKED
117:                       if  (new_message_in_rx1_buffer) {
19B6  5184     MOVF new_message_in_rx1_buffer, W, BANKED
19B8  E00A     BZ 0x19CE
118:                           new_message_in_rx1_buffer=0;
19BA  6B84     CLRF new_message_in_rx1_buffer, BANKED
19BC  D82C     RCALL PL54
119:                           putch_uartfunction_ptr=UART1_Write;
120:                           printf("NEW MESSAGE RECEIVED: %s",&uart1RxBuffer[1]);
19BE  0E46     MOVLW 0x46
19C0  6FBD     MOVWF fmt, BANKED
19C2  0EA1     MOVLW 0xA1
19C4  6FBE     MOVWF 0xBE, BANKED
19C6  0E01     MOVLW 0x1
19C8  6FBF     MOVWF 0xBF, BANKED
19CA  ECBA     CALL 0x2374, 0
19CC  F011     NOP
121:                       }   
122:                       if  (new_message_in_rx2_buffer) {
19CE  5181     MOVF new_message_in_rx2_buffer, W, BANKED
19D0  E00A     BZ 0x19E6
123:                           new_message_in_rx2_buffer=0;
19D2  6B81     CLRF new_message_in_rx2_buffer, BANKED
19D4  D825     RCALL PL58
124:                            putch_uartfunction_ptr=UART2_Write;
125:                           printf("NEW MESSAGE RECEIVED: %s",&uart2RxBuffer[1]);
19D6  0E46     MOVLW 0x46
19D8  6FBD     MOVWF fmt, BANKED
19DA  0E01     MOVLW 0x1
19DC  6FBE     MOVWF 0xBE, BANKED
19DE  0E01     MOVLW 0x1
19E0  6FBF     MOVWF 0xBF, BANKED
19E2  ECBA     CALL 0x2374, 0
19E4  F011     NOP
126:                       }   
127:                       __delay_ms(1);
19E6  0E15     MOVLW 0x15
19E8  0100     MOVLB 0x0
19EA  6FC1     MOVWF 0xC1, BANKED
19EC  0EC6     MOVLW 0xC6
19EE  2EE8     DECFSZ 0xFE8, F, ACCESS
19F0  D7FE     BRA 0x19EE
19F2  2FC1     DECFSZ 0xC1, F, BANKED
19F4  D7FC     BRA 0x19EE
19F6  F000     NOP
128:                   }
19F8  0100     MOVLB 0x0
19FA  4BC4     INFSNZ i, F, BANKED
19FC  2BC5     INCF 0xC5, F, BANKED
19FE  0EE8     MOVLW 0xE8
1A00  5DC4     SUBWF i, W, BANKED
1A02  0E03     MOVLW 0x3
1A04  59C5     SUBWFB 0xC5, W, BANKED
1A06  E2C9     BC 0x199A
1A08  D7D6     BRA 0x19B6
129:               }
130:           } 
131:             
132:           /**
133:            End of File
134:           */
---  C:/Users/emp/Desktop/SM/Curso/Drive/Progs/PIC18fusion/01 - Basic/Basic_UART_INTs_SPI.X/WS2812.c  ---
1:             
2:             #include "mcc_generated_files/mcc.h"
3:             #include <stdint.h>
4:             #include "my_defs.h"
5:             
6:             /*
7:             WS2812B timing
8:             
9:             A 0 bit is given when the high voltage time is less than roughly 0.35s. There is no minimum value to this.
10:             * 
11:            The low voltage time is almost completely irrelevant, and signal periodicity is irrelevant. 
12:             * As long as you don't pull low for 50s between high voltage points, you are fine.
13:            What this means is that all you need to worry about is how long your high voltage time lasts. 
14:             * Under 0.35s is a 0. Over 0.35 is a 1. 
15:             
16:             */
17:            
18:            #define DEFAULT_LED_TEMPO1 1  // em centesimos de s (TMR0 period = 10ms)
19:            #define DEFAULT_LED_TEMPO0 100   // em centesimos de s (TMR0 period = 10ms)
20:            
21:            uint8_t     ws2812_bits[24];
22:            uint8_t     led_rgb_on[3]={0,255,0};
23:            uint8_t     led_rgb_off[3]={0,0,0};
24:            uint16_t    led_tempo1=DEFAULT_LED_TEMPO1;        // em centesimos de s (TMR0 period = 10ms)
25:            uint16_t    led_tempo0=DEFAULT_LED_TEMPO0;        // em centesimos de s (TMR0 period = 10ms)
26:            uint8_t     led_status=ON;
27:            
28:            
29:            void led_update(void) {
30:                return;
31:                if (led_status) {
32:                    ws2812_send(led_rgb_on[0],led_rgb_on[1],led_rgb_on[2]);
33:                    led_tempo1--;
34:                    if (!led_tempo1) {
35:                        led_status = ! led_status;
36:                        led_tempo1=DEFAULT_LED_TEMPO1;
37:                    }
38:                }     
39:                else
40:                    ws2812_send(led_rgb_off[0],led_rgb_off[1],led_rgb_off[2]);
41:                    led_tempo0--;
42:                    if (!led_tempo0) {
43:                        led_status = ! led_status;
44:                        led_tempo0=DEFAULT_LED_TEMPO0;
45:                    }
46:            }
2460  0012     RETURN 0
47:            
48:            
49:            void led_initialize(void) {
50:            
51:                ws2812_send(0,0,0);
23DE  0E00     MOVLW 0x0
23E0  6A0A     CLRF dividend, ACCESS
23E2  6A0B     CLRF blue, ACCESS
23E4  EF15     GOTO 0x1A2A
23E6  F00D     NOP
52:                 
53:            }
54:            
55:            
56:            uint32_t bitflip(uint8_t b) {
57:               b = (uint8_t)( (b & 0xF0) >> 4 | (b & 0x0F) << 4 );
58:               b = (uint8_t)( (b & 0xCC) >> 2 | (b & 0x33) << 2 );
59:               b = (uint8_t)( (b & 0xAA) >> 1 | (b & 0x55) << 1 );
60:               return (uint32_t)b;
61:            }
62:            
63:                                           
64:                                           
65:                                           
66:            // use of do{...} while (0) allow the macro to be inserted in a multi statement if correctly.https://www.microchip.com/forums/m909941.aspx
67:            #define SET_DIN_WS2812B(bit)  do { LATBbits.LATB7 = bit; } while(0) 
68:            
69:            void ws2812_send(uint8_t red, uint8_t green, uint8_t blue) {
18AE  6E06     MOVWF red, ACCESS
1A2A  6E0E     MOVWF product, ACCESS
70:            int8_t i,j;
71:            
72:            
73:                // Build in ws2812_bits the bit sequence to send to ws2812 (THe order is GGGGGGGG RRRRRRRR BBBBBBBB with MSB first)
74:                //The use of an array allow to reduce the execution time sending the bits
75:                for (i=0,j=7;j>=0;j--,i++)
18B0  6A07     CLRF i, ACCESS
18B2  0E07     MOVLW 0x7
18B4  6E08     MOVWF j, ACCESS
1A2C  6A0F     CLRF duration, ACCESS
1A2E  0E07     MOVLW 0x7
1A30  6E10     MOVWF j, ACCESS
76:                  ws2812_bits[i]= ((green & (1 << j)) !=0) ;
18B6  D840     RCALL PL8
18B8  1402     ANDWF green, W, ACCESS
18BA  0E01     MOVLW 0x1
18BC  D84D     RCALL __end_ofPL8
18BE  AE08     BTFSS j, 7, ACCESS
18C0  D7FA     BRA 0x18B6
1A32  D83F     RCALL PL6
1A34  140A     ANDWF dividend, W, ACCESS
1A36  D84D     RCALL __end_ofPL6
1A38  AE10     BTFSS j, 7, ACCESS
1A3A  D7FB     BRA 0x1A32
77:                
78:                for (j=7;j>=0;j--,i++)
18C2  0E07     MOVLW 0x7
18C4  6E08     MOVWF j, ACCESS
1A3C  0E07     MOVLW 0x7
1A3E  6E10     MOVWF j, ACCESS
79:                  ws2812_bits[i]= ((red & (1 << j)) !=0) ;
18C6  D838     RCALL PL8
18C8  1406     ANDWF red, W, ACCESS
18CA  0E01     MOVLW 0x1
18CC  D845     RCALL __end_ofPL8
18CE  AE08     BTFSS j, 7, ACCESS
18D0  D7FA     BRA 0x18C6
1A40  D838     RCALL PL6
1A42  140E     ANDWF product, W, ACCESS
1A44  D846     RCALL __end_ofPL6
1A46  AE10     BTFSS j, 7, ACCESS
1A48  D7FB     BRA 0x1A40
80:            
81:                for (j=7;j>=0;j--,i++)
18D2  0E07     MOVLW 0x7
18D4  6E08     MOVWF j, ACCESS
1A4A  0E07     MOVLW 0x7
1A4C  6E10     MOVWF j, ACCESS
82:                  ws2812_bits[i]= ((blue & (1 << j)) !=0) ;
18D6  D830     RCALL PL8
18D8  1403     ANDWF blue, W, ACCESS
18DA  0E01     MOVLW 0x1
18DC  D83D     RCALL __end_ofPL8
18DE  AE08     BTFSS j, 7, ACCESS
18E0  D7FA     BRA 0x18D6
1A4E  D831     RCALL PL6
1A50  140B     ANDWF blue, W, ACCESS
1A52  D83F     RCALL __end_ofPL6
1A54  AE10     BTFSS j, 7, ACCESS
1A56  D7FB     BRA 0x1A4E
83:            
84:            
85:                //_XTAL_FREQ =64000000  1/64000000 = 15.625 ns  4*15.625 = 62.5ns minimum instruction cycle time
86:                // 0.35us=350ns / 62.5 ns = 5.6 => 7 nops (com 6 falhava...))
87:                // Os valores menores so: (Estesvalores foram testados na pratica, mas nos datasheets eles indicam tempo maiores!!!)
88:                // BIT 1     1                   0
89:                //         7 nops (437.5ns)    2 nops (125ns)    Tbit=562.5ns 
90:                //              
91:                // BIT 0     1         0
92:                //         2 nops    1 nops
93:                // Agora esto simtricos e iguais a 750ns (12 nops)+ 250 ns (4 nops)
94:                // O tempo de separao entre bits, tempo a zero, n  critico mas no pode ser  (tenmpo a zero da onda) no pode ser superior a 40us (testei 40us OK,  50us deu mal))
95:                // S programa por causa dos saltos (if else mete ai um overhad de 1us! S funciona porque os leds no ligam muito ao tempo a zero!             
96:                INTERRUPT_GlobalInterruptHighDisable();
18E2  9ED2     BCF 0xFD2, 7, ACCESS
1A58  9ED2     BCF 0xFD2, 7, ACCESS
97:                INTERRUPT_GlobalInterruptLowDisable();
18E4  9CD2     BCF 0xFD2, 6, ACCESS
1A5A  9CD2     BCF 0xFD2, 6, ACCESS
98:                for(i=0;i<24;i++) {
18E6  6A07     CLRF i, ACCESS
1A5C  6A0F     CLRF duration, ACCESS
99:                    if  (ws2812_bits[i]==1) {
18E8  5007     MOVF i, W, ACCESS
18EA  D83C     RCALL PL50
18EC  E10E     BNZ 0x190A
1A5E  500F     MOVF duration, W, ACCESS
1A60  ECB2     CALL 0x1964, 0
1A62  F00C     NOP
1A64  E10E     BNZ 0x1A82
100:                       A_LED_SetHigh();
18EE  8EBB     BSF 0xFBB, 7, ACCESS
1A66  8EBB     BSF 0xFBB, 7, ACCESS
101:                       NOP();
18F0  F000     NOP
1A68  F000     NOP
102:                       NOP();
18F2  F000     NOP
1A6A  F000     NOP
103:                       NOP();
18F4  F000     NOP
1A6C  F000     NOP
104:                       NOP();
18F6  F000     NOP
1A6E  F000     NOP
105:                       NOP();
18F8  F000     NOP
1A70  F000     NOP
106:                       NOP();
18FA  F000     NOP
1A72  F000     NOP
107:                       NOP();
18FC  F000     NOP
1A74  F000     NOP
108:                       NOP();
18FE  F000     NOP
1A76  F000     NOP
109:                       NOP();
1900  F000     NOP
1A78  F000     NOP
110:                       NOP();
1902  F000     NOP
1A7A  F000     NOP
111:                       NOP();
1904  F000     NOP
1A7C  F000     NOP
112:           //            NOP();            //Para acertar para os 750ns - ver disassembly
113:                       A_LED_SetLow();
1906  9EBB     BCF 0xFBB, 7, ACCESS
1908  D00D     BRA 0x1924
1A7E  9EBB     BCF 0xFBB, 7, ACCESS
1A80  D00D     BRA 0x1A9C
114:                       NOP();
115:                       NOP();
116:                       NOP();
117:                       NOP();
118:                       
119:                   }
120:                   else {
121:                       A_LED_SetHigh();
190A  8EBB     BSF 0xFBB, 7, ACCESS
1A82  8EBB     BSF 0xFBB, 7, ACCESS
122:                       NOP();
190C  F000     NOP
1A84  F000     NOP
123:                       NOP();
190E  F000     NOP
1A86  F000     NOP
124:                       NOP();
1910  F000     NOP
1A88  F000     NOP
125:           //            NOP();            //Para acertar para os 250ns - ver disassembly
126:                       A_LED_SetLow();
1912  9EBB     BCF 0xFBB, 7, ACCESS
1A8A  9EBB     BCF 0xFBB, 7, ACCESS
127:                       NOP();
1914  F000     NOP
1A8C  F000     NOP
128:                       NOP();
1916  F000     NOP
1A8E  F000     NOP
129:                       NOP();
1918  F000     NOP
1A90  F000     NOP
130:                       NOP();
191A  F000     NOP
1A92  F000     NOP
131:                       NOP();
191C  F000     NOP
1A94  F000     NOP
132:                       NOP();
191E  F000     NOP
1A96  F000     NOP
133:                       NOP();
1920  F000     NOP
1A98  F000     NOP
134:                       NOP();
1922  F000     NOP
1A9A  F000     NOP
135:                       NOP();
1924  F000     NOP
1A9C  F000     NOP
136:                       NOP();
1926  F000     NOP
1A9E  F000     NOP
137:                       NOP();
1928  F000     NOP
1AA0  F000     NOP
138:                       NOP();
192A  F000     NOP
1AA2  F000     NOP
139:                                  
140:                   }
141:                   
142:               }
192C  2A07     INCF i, F, ACCESS
1AA4  2A0F     INCF duration, F, ACCESS
1AA6  500F     MOVF duration, W, ACCESS
1AA8  0A80     XORLW 0x80
1AAA  0F68     ADDLW 0x68
1AAC  E3D8     BNC 0x1A5E
143:               
144:               INTERRUPT_GlobalInterruptHighEnable();
1AAE  EFB7     GOTO 0x196E
1AB0  F00C     NOP
145:               INTERRUPT_GlobalInterruptLowEnable();
146:           
147:            
148:           }
149:           
150:           void basic_test_ws2812_bits(void) {
151:               for(;;) {
152:                   ws2812_send(0, 0xFF, 00) ;
22DC  680A     SETF dividend, ACCESS
22DE  0E00     MOVLW 0x0
22E0  6A0B     CLRF blue, ACCESS
22E2  EC15     CALL 0x1A2A, 0
22E4  F00D     NOP
153:               __delay_us(300);
22E6  0E07     MOVLW 0x7
22E8  6E11     MOVWF s, ACCESS
22EA  0E3A     MOVLW 0x3A
22EC  2EE8     DECFSZ 0xFE8, F, ACCESS
22EE  D7FE     BRA 0x22EC
22F0  2E11     DECFSZ s, F, ACCESS
22F2  D7FC     BRA 0x22EC
22F4  D000     BRA 0x22F6
154:           
155:               }
22F6  D7F2     BRA basic_test_ws2812_bits
156:           
157:           }
158:           
159:           
160:           void basic_test_ws2812(void) {
161:               for (;;) {
162:               printf("RED\r\n");
163:                   ws2812_send(255, 0, 0) ;
164:                   Delay_ms(1000);
165:                   
166:                   printf("GREEN\r\n");
167:                   ws2812_send(0, 255, 0) ;
168:                   Delay_ms(1000);
169:                           
170:                   printf("BLUE\r\n");
171:                   ws2812_send(0, 0, 255) ;
172:                   Delay_ms(1000);
173:                 
174:                   printf("WHITE\r\n");
175:                   ws2812_send(255, 255, 255) ;
176:                   Delay_ms(1000);
177:                 
178:                   printf("BLACK\r\n");
179:                   ws2812_send(0, 0, 0) ;
180:                   Delay_ms(2000);
181:               } 
182:           }
183:           
---  C:/Users/emp/AppData/Local/Temp/xcAsjc0.s  ---------------------------------------------------------
1DD8  0EBE     MOVLW 0xBE
1DDA  6EF6     MOVWF 0xFF6, ACCESS
1DDC  0E23     MOVLW 0x23
1DDE  6EF7     MOVWF 0xFF7, ACCESS
1DE0  0E00     MOVLW 0x0
1DE2  6EF8     MOVWF 0xFF8, ACCESS
1DE4  EE00     LFSR 0, 0xE2
1DE8  EE10     LFSR 1, 0x10
1DEC  0009     TBLRD*+
1DF4  50E5     MOVF 0xFE5, W, ACCESS
1DF6  50E1     MOVF 0xFE1, W, ACCESS
1DF8  E1F9     BNZ 0x1DEC
1DFA  0E6A     MOVLW 0x6A
1DFC  6EF6     MOVWF 0xFF6, ACCESS
1DFE  0E24     MOVLW 0x24
1E00  6EF7     MOVWF 0xFF7, ACCESS
1E02  0E00     MOVLW 0x0
1E04  6EF8     MOVWF 0xFF8, ACCESS
1E06  0009     TBLRD*+
1E0E  EE00     LFSR 0, 0x200
1E12  0EF0     MOVLW 0xF0
1E14  6AEE     CLRF 0xFEE, ACCESS
1E16  06E8     DECF 0xFE8, F, ACCESS
1E18  E1FD     BNZ 0x1E14
1E1A  EE00     LFSR 0, 0x100
1E1E  0EF0     MOVLW 0xF0
1E20  6AEE     CLRF 0xFEE, ACCESS
1E22  06E8     DECF 0xFE8, F, ACCESS
1E24  E1FD     BNZ 0x1E20
1E26  EE00     LFSR 0, 0x60
1E2A  0E47     MOVLW 0x47
1E2C  6AEE     CLRF 0xFEE, ACCESS
1E2E  06E8     DECF 0xFE8, F, ACCESS
1E30  E1FD     BNZ 0x1E2C
1E32  6A53     CLRF uart1TxHead, ACCESS
1E34  6A52     CLRF uart1TxTail, ACCESS
1E36  6A51     CLRF uart2TxHead, ACCESS
1E38  6A50     CLRF uart2TxTail, ACCESS
1E3A  6A4F     CLRF 0x4F, ACCESS
1E3C  6A4E     CLRF flags, ACCESS
1E3E  0E08     MOVLW 0x8
1E40  6ED5     MOVWF 0xFD5, ACCESS
1E42  0E00     MOVLW 0x0
1E44  6ED6     MOVWF 0xFD6, ACCESS
1E46  0E00     MOVLW 0x0
1E48  6ED7     MOVWF 0xFD7, ACCESS
1E4A  0100     MOVLB 0x0
1E4C  EFBA     GOTO 0x1974
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/strlen.c  ------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
218A  C00A     MOVFF dividend, status
218C  F00C     NOP
218E  C00B     MOVFF blue, i
2190  F00D     NOP
8:             	while(*s) {
2192  D002     BRA 0x2198
219A  F02B     NOP
219C  FFD9     NOP
21A0  F02F     NOP
21A2  FFDA     NOP
21A4  50DF     MOVF 0xFDF, W, ACCESS
21A6  E1F6     BNZ 0x2194
9:             		s++;
2194  4A0A     INFSNZ dividend, F, ACCESS
2196  2A0B     INCF blue, F, ACCESS
10:            	}
11:            	return (size_t)(s-a);
21A8  500C     MOVF status, W, ACCESS
21AA  5C0A     SUBWF dividend, W, ACCESS
21AC  6E0A     MOVWF dividend, ACCESS
21AE  500D     MOVF i, W, ACCESS
21B0  580B     SUBWFB blue, W, ACCESS
21B2  6E0B     MOVWF blue, ACCESS
12:            }
21B4  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/printf.c  ------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
2374  0EBE     MOVLW 0xBE
2376  6FC0     MOVWF ap, BANKED
10:            	ret = vfprintf(stdout, fmt, ap);
2378  6BB9     CLRF fp, BANKED
237A  6BBA     CLRF 0xBA, BANKED
237C  C0BD     MOVFF fmt, fmt
237E  F0BB     NOP
2380  0EC0     MOVLW 0xC0
2382  6FBC     MOVWF ap, BANKED
2384  EFD1     GOTO 0x1FA2
2386  F00F     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/nf_fputs.c  ----------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
215C  6A19     CLRF i, ACCESS
215E  6A1A     CLRF counter, ACCESS
14:                while ((c = *(s + i))) {
2160  D00B     BRA 0x2178
2178  5015     MOVF fp, W, ACCESS
217A  2419     ADDWF i, W, ACCESS
217C  6ED9     MOVWF 0xFD9, ACCESS
217E  6ADA     CLRF 0xFDA, ACCESS
2180  50DF     MOVF 0xFDF, W, ACCESS
2182  6E18     MOVWF c, ACCESS
2184  5018     MOVF c, W, ACCESS
2186  E1ED     BNZ 0x2162
15:            	fputc(c,fp);
2162  C018     MOVFF c, status
2164  F00C     NOP
2166  6A0D     CLRF i, ACCESS
2168  C016     MOVFF fp, product
216A  F00E     NOP
216C  C017     MOVFF s, duration
216E  F00F     NOP
2170  EC28     CALL 0x1E50, 0
2172  F00F     NOP
16:                    ++i;
2174  4A19     INFSNZ i, F, ACCESS
2176  2A1A     INCF counter, F, ACCESS
17:                }
18:                return i;
19:            }
2188  0012     RETURN 0
20:            
21:            #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/nf_fputc.c  ----------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
1E50  500E     MOVF product, W, ACCESS
1E52  100F     IORWF duration, W, ACCESS
1E54  E003     BZ 0x1E5C
1E56  500E     MOVF product, W, ACCESS
1E58  100F     IORWF duration, W, ACCESS
1E5A  E103     BNZ 0x1E62
13:                    putch((char)c);
1E5C  500C     MOVF status, W, ACCESS
1E5E  EF97     GOTO 0x232E
1E60  F011     NOP
14:                } else {
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
1E62  D81E     RCALL PL36
1E64  50DE     MOVF 0xFDE, W, ACCESS
1E66  10DE     IORWF 0xFDE, W, ACCESS
1E68  E011     BZ 0x1E8C
1E6A  D81A     RCALL PL36
1E6C  EE10     LFSR 1, 0x2
1E6E  F002     NOP
1E70  500E     MOVF product, W, ACCESS
1E72  26E1     ADDWF 0xFE1, F, ACCESS
1E74  500F     MOVF duration, W, ACCESS
1E76  22E2     ADDWFC 0xFE2, F, ACCESS
1E78  50DE     MOVF 0xFDE, W, ACCESS
1E7A  5CE6     SUBWF 0xFE6, W, ACCESS
1E7C  50E6     MOVF 0xFE6, W, ACCESS
1E7E  0A80     XORLW 0x80
1E80  6E14     MOVWF 0x14, ACCESS
1E82  50DE     MOVF 0xFDE, W, ACCESS
1E84  0A80     XORLW 0x80
1E86  5814     SUBWFB 0x14, W, ACCESS
1E88  B0D8     BTFSC 0xFD8, 0, ACCESS
1E8A  0012     RETURN 0
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
19:            #pragma warning pop
20:            			++fp->count;
1E8C  EE20     LFSR 2, 0x2
1E8E  F002     NOP
1E90  500E     MOVF product, W, ACCESS
1E92  26D9     ADDWF 0xFD9, F, ACCESS
1E94  500F     MOVF duration, W, ACCESS
1E96  22DA     ADDWFC 0xFDA, F, ACCESS
1E98  2ADE     INCF 0xFDE, F, ACCESS
1E9A  0E00     MOVLW 0x0
1E9C  22DD     ADDWFC 0xFDD, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
1E9E  0C00     RETLW 0x0
25:            
26:            #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/isspace.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
2092  0E01     MOVLW 0x1
2094  6E10     MOVWF j, ACCESS
2096  0E20     MOVLW 0x20
2098  180A     XORWF dividend, W, ACCESS
209A  100B     IORWF blue, W, ACCESS
209C  E011     BZ 0x20C0
209E  0EF7     MOVLW 0xF7
20A0  6E0C     MOVWF status, ACCESS
20A2  680D     SETF i, ACCESS
20A4  C00A     MOVFF dividend, product
20A6  F00E     NOP
20A8  C00B     MOVFF blue, duration
20AA  F00F     NOP
20AC  500C     MOVF status, W, ACCESS
20AE  260E     ADDWF product, F, ACCESS
20B0  500D     MOVF i, W, ACCESS
20B2  220F     ADDWFC duration, F, ACCESS
20B4  500F     MOVF duration, W, ACCESS
20B6  E103     BNZ 0x20BE
20B8  0E05     MOVLW 0x5
20BA  5C0E     SUBWF product, W, ACCESS
20BC  E301     BNC 0x20C0
20BE  6A10     CLRF j, ACCESS
20C0  C010     MOVFF j, dividend
20C2  F00A     NOP
20C4  6A0B     CLRF blue, ACCESS
8:             }
20C6  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/isdigit.c  -----------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
21B6  0ED0     MOVLW 0xD0
21B8  6E0C     MOVWF status, ACCESS
21BA  680D     SETF i, ACCESS
21BC  C00A     MOVFF dividend, product
21BE  F00E     NOP
21C0  C00B     MOVFF blue, duration
21C2  F00F     NOP
21C4  500C     MOVF status, W, ACCESS
21C6  260E     ADDWF product, F, ACCESS
21C8  500D     MOVF i, W, ACCESS
21CA  220F     ADDWFC duration, F, ACCESS
21CC  500F     MOVF duration, W, ACCESS
21CE  E105     BNZ 0x21DA
21D0  0E0A     MOVLW 0xA
21D2  5C0E     SUBWF product, W, ACCESS
21D4  E202     BC 0x21DA
21D6  0E01     MOVLW 0x1
21D8  D001     BRA 0x21DC
21DA  0E00     MOVLW 0x0
21DC  6E0A     MOVWF dividend, ACCESS
21DE  6A0B     CLRF blue, ACCESS
8:             }
21E0  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/doprnt.c  ------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
1CE4  A04E     BTFSS flags, 0, ACCESS
1CE6  D003     BRA 0x1CEE
78:                    fputs((const char *)buf, fp);
1CE8  D833     RCALL PL34
1CEA  ECAE     CALL 0x215C, 0
1CEC  F010     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
1CEE  BE1F     BTFSC 0x1F, 7, ACCESS
1CF0  D005     BRA 0x1CFC
1CF2  C01E     MOVFF p, w
1CF4  F023     NOP
1CF6  C01F     MOVFF 0x1F, 0x24
1CF8  F024     NOP
1CFA  D002     BRA 0x1D00
1CFC  6A23     CLRF w, ACCESS
1CFE  6A24     CLRF 0x24, ACCESS
83:                i = 0;
1D00  6A21     CLRF i, ACCESS
1D02  6A22     CLRF 0x22, ACCESS
84:                while (i < w) {
1D04  D00B     BRA 0x1D1C
1D1C  5023     MOVF w, W, ACCESS
1D1E  5C21     SUBWF i, W, ACCESS
1D20  5022     MOVF 0x22, W, ACCESS
1D22  0A80     XORLW 0x80
1D24  6E20     MOVWF 0x20, ACCESS
1D26  5024     MOVF 0x24, W, ACCESS
1D28  0A80     XORLW 0x80
1D2A  5820     SUBWFB 0x20, W, ACCESS
1D2C  E3EC     BNC 0x1D06
85:                    fputc(' ', fp);
1D06  6A0D     CLRF i, ACCESS
1D08  0E20     MOVLW 0x20
1D0A  6E0C     MOVWF status, ACCESS
1D0C  C01B     MOVFF sign, product
1D0E  F00E     NOP
1D10  C01C     MOVFF a, duration
1D12  F00F     NOP
1D14  EC28     CALL 0x1E50, 0
1D16  F00F     NOP
86:                    ++i;
1D18  4A21     INFSNZ i, F, ACCESS
1D1A  2A22     INCF 0x22, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
1D2E  B04E     BTFSC flags, 0, ACCESS
1D30  D003     BRA 0x1D38
1D32  D80E     RCALL PL34
91:                    fputs((const char *)buf, fp);
1D34  ECAE     CALL 0x215C, 0
1D36  F010     NOP
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
1D38  C01D     MOVFF buf, dividend
1D3A  F00A     NOP
1D3C  6A0B     CLRF blue, ACCESS
1D3E  ECC5     CALL 0x218A, 0
1D40  F010     NOP
1D42  5023     MOVF w, W, ACCESS
1D44  240A     ADDWF dividend, W, ACCESS
1D46  6E1B     MOVWF sign, ACCESS
1D48  5024     MOVF 0x24, W, ACCESS
1D4A  200B     ADDWFC blue, W, ACCESS
1D4C  6E1C     MOVWF a, ACCESS
95:            }
1D4E  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
1086  C027     MOVFF d, n
1088  F03F     NOP
108A  C028     MOVFF 0x28, 0x40
108C  F040     NOP
108E  C029     MOVFF l, 0x41
1090  F041     NOP
1092  C02A     MOVFF 0x2A, 0x42
1094  F042     NOP
1096  C02B     MOVFF 0x2B, 0x43
1098  F043     NOP
109A  C02C     MOVFF 0x2C, 0x44
109C  F044     NOP
109E  C02D     MOVFF 0x2D, 0x45
10A0  F045     NOP
10A2  C02E     MOVFF 0x2E, 0x46
10A4  F046     NOP
294:               s = n < 0 ? 1 : 0;
10A6  0E01     MOVLW 0x1
10A8  AE46     BTFSS 0x46, 7, ACCESS
10AA  0E00     MOVLW 0x0
10AC  6E3D     MOVWF s, ACCESS
10AE  6A3E     CLRF 0x3E, ACCESS
295:               if (s) {
10B0  503D     MOVF s, W, ACCESS
10B2  103E     IORWF 0x3E, W, ACCESS
10B4  E010     BZ 0x10D6
296:                   n = -n;
10B6  1E46     COMF 0x46, F, ACCESS
10B8  1E45     COMF 0x45, F, ACCESS
10BA  1E44     COMF 0x44, F, ACCESS
10BC  1E43     COMF 0x43, F, ACCESS
10BE  1E42     COMF 0x42, F, ACCESS
10C0  1E41     COMF 0x41, F, ACCESS
10C2  1E40     COMF 0x40, F, ACCESS
10C4  6C3F     NEGF n, ACCESS
10C6  0E00     MOVLW 0x0
10C8  2240     ADDWFC 0x40, F, ACCESS
10CA  2241     ADDWFC 0x41, F, ACCESS
10CC  2242     ADDWFC 0x42, F, ACCESS
10CE  2243     ADDWFC 0x43, F, ACCESS
10D0  2244     ADDWFC 0x44, F, ACCESS
10D2  2245     ADDWFC 0x45, F, ACCESS
10D4  2246     ADDWFC 0x46, F, ACCESS
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
10D6  AF80     BTFSS 0x80, 7, BANKED
301:                   flags &= ~ZERO_FLAG;
10D8  924E     BCF flags, 1, ACCESS
302:               }
303:               p = (0 < prec) ? prec : 1;
10DA  BF80     BTFSC 0x80, 7, BANKED
10DC  D004     BRA 0x10E6
10DE  5180     MOVF 0x80, W, BANKED
10E0  E106     BNZ 0x10EE
10E2  057F     DECF prec, W, BANKED
10E4  E204     BC 0x10EE
10E6  6A3A     CLRF 0x3A, ACCESS
10E8  0E01     MOVLW 0x1
10EA  6E39     MOVWF p, ACCESS
10EC  D004     BRA 0x10F6
10EE  C07F     MOVFF prec, p
10F0  F039     NOP
10F2  C080     MOVFF 0x80, 0x3A
10F4  F03A     NOP
304:               w = width;
10F6  C07D     MOVFF width, w
10F8  F03B     NOP
10FA  C07E     MOVFF 0x7E, 0x3C
10FC  F03C     NOP
305:               if (s || (flags & PLUS_FLAG)) {
10FE  503D     MOVF s, W, ACCESS
1100  103E     IORWF 0x3E, W, ACCESS
1102  E102     BNZ 0x1108
1104  A44E     BTFSS flags, 2, ACCESS
1106  D003     BRA 0x110E
306:                   --w;
1108  063B     DECF w, F, ACCESS
110A  A0D8     BTFSS 0xFD8, 0, ACCESS
110C  063C     DECF 0x3C, F, ACCESS
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
110E  6A48     CLRF 0x48, ACCESS
1110  0E1F     MOVLW 0x1F
1112  6E47     MOVWF i, ACCESS
311:               dbuf[i] = '\0';
1114  6BA6     CLRF 0xA6, BANKED
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1116  D069     BRA 0x11EA
11EA  BE48     BTFSC 0x48, 7, ACCESS
11EC  D01B     BRA 0x1224
11EE  5048     MOVF 0x48, W, ACCESS
11F0  E102     BNZ 0x11F6
11F2  0447     DECF i, W, ACCESS
11F4  E317     BNC 0x1224
11F6  503F     MOVF n, W, ACCESS
11F8  1040     IORWF 0x40, W, ACCESS
11FA  1041     IORWF 0x41, W, ACCESS
11FC  1042     IORWF 0x42, W, ACCESS
11FE  1043     IORWF 0x43, W, ACCESS
1200  1044     IORWF 0x44, W, ACCESS
1202  1045     IORWF 0x45, W, ACCESS
1204  1046     IORWF 0x46, W, ACCESS
1206  E188     BNZ 0x1118
1208  BE3A     BTFSC 0x3A, 7, ACCESS
120A  D004     BRA 0x1214
120C  503A     MOVF 0x3A, W, ACCESS
120E  E184     BNZ 0x1118
1210  0439     DECF p, W, ACCESS
1212  E282     BC 0x1118
1214  BE3C     BTFSC 0x3C, 7, ACCESS
1216  D006     BRA 0x1224
1218  503C     MOVF 0x3C, W, ACCESS
121A  E102     BNZ 0x1220
121C  043B     DECF w, W, ACCESS
121E  E302     BNC 0x1224
1220  B24E     BTFSC flags, 1, ACCESS
1222  D77A     BRA 0x1118
313:                   --i;
1118  0647     DECF i, F, ACCESS
111A  A0D8     BTFSS 0xFD8, 0, ACCESS
111C  0648     DECF 0x48, F, ACCESS
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
111E  D8A9     RCALL PL48
1120  C03F     MOVFF n, dividend
1122  F00A     NOP
1124  C040     MOVFF 0x40, blue
1126  F00B     NOP
1128  C041     MOVFF 0x41, status
112A  F00C     NOP
112C  C042     MOVFF 0x42, i
112E  F00D     NOP
1130  C043     MOVFF 0x43, product
1132  F00E     NOP
1134  C044     MOVFF 0x44, duration
1136  F00F     NOP
1138  C045     MOVFF 0x45, j
113A  F010     NOP
113C  C046     MOVFF 0x46, s
113E  F011     NOP
1140  0E0A     MOVLW 0xA
1142  6E12     MOVWF divisor, ACCESS
1144  6A13     CLRF 0x13, ACCESS
1146  6A14     CLRF 0x14, ACCESS
1148  6A15     CLRF fp, ACCESS
114A  6A16     CLRF fp, ACCESS
114C  6A17     CLRF s, ACCESS
114E  6A18     CLRF c, ACCESS
1150  6A19     CLRF i, ACCESS
1152  EC59     CALL 0x16B2, 0
1154  F00B     NOP
1156  C00A     MOVFF dividend, 0x2F
1158  F02F     NOP
115A  C00B     MOVFF blue, 0x30
115C  F030     NOP
115E  C00C     MOVFF status, 0x31
1160  F031     NOP
1162  C00D     MOVFF i, 0x32
1164  F032     NOP
1166  C00E     MOVFF product, 0x33
1168  F033     NOP
116A  C00F     MOVFF duration, 0x34
116C  F034     NOP
116E  C010     MOVFF j, 0x35
1170  F035     NOP
1172  C011     MOVFF s, 0x36
1174  F036     NOP
1176  C02F     MOVFF 0x2F, a
1178  F01C     NOP
117A  C031     MOVFF 0x31, buf
117C  F01D     NOP
117E  EC96     CALL 0x212C, 0
1180  F010     NOP
1182  501C     MOVF a, W, ACCESS
1184  0F30     ADDLW 0x30
1186  6EDF     MOVWF 0xFDF, ACCESS
315:                   --p;
1188  0639     DECF p, F, ACCESS
118A  A0D8     BTFSS 0xFD8, 0, ACCESS
118C  063A     DECF 0x3A, F, ACCESS
316:                   --w;
118E  063B     DECF w, F, ACCESS
1190  A0D8     BTFSS 0xFD8, 0, ACCESS
1192  063C     DECF 0x3C, F, ACCESS
317:                   n = n / 10;
1194  C03F     MOVFF n, dividend
1196  F00A     NOP
1198  C040     MOVFF 0x40, blue
119A  F00B     NOP
119C  C041     MOVFF 0x41, status
119E  F00C     NOP
11A0  C042     MOVFF 0x42, i
11A2  F00D     NOP
11A4  C043     MOVFF 0x43, product
11A6  F00E     NOP
11A8  C044     MOVFF 0x44, duration
11AA  F00F     NOP
11AC  C045     MOVFF 0x45, j
11AE  F010     NOP
11B0  C046     MOVFF 0x46, s
11B2  F011     NOP
11B4  0E0A     MOVLW 0xA
11B6  6E12     MOVWF divisor, ACCESS
11B8  6A13     CLRF 0x13, ACCESS
11BA  6A14     CLRF 0x14, ACCESS
11BC  6A15     CLRF fp, ACCESS
11BE  6A16     CLRF fp, ACCESS
11C0  6A17     CLRF s, ACCESS
11C2  6A18     CLRF c, ACCESS
11C4  6A19     CLRF i, ACCESS
11C6  EC35     CALL 0x146A, 0
11C8  F00A     NOP
11CA  C00A     MOVFF dividend, n
11CC  F03F     NOP
11CE  C00B     MOVFF blue, 0x40
11D0  F040     NOP
11D2  C00C     MOVFF status, 0x41
11D4  F041     NOP
11D6  C00D     MOVFF i, 0x42
11D8  F042     NOP
11DA  C00E     MOVFF product, 0x43
11DC  F043     NOP
11DE  C00F     MOVFF duration, 0x44
11E0  F044     NOP
11E2  C010     MOVFF j, 0x45
11E4  F045     NOP
11E6  C011     MOVFF s, 0x46
11E8  F046     NOP
318:               }
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
1224  503D     MOVF s, W, ACCESS
1226  103E     IORWF 0x3E, W, ACCESS
1228  E102     BNZ 0x122E
122A  A44E     BTFSS flags, 2, ACCESS
122C  D010     BRA 0x124E
322:                   --i;
122E  0647     DECF i, F, ACCESS
1230  A0D8     BTFSS 0xFD8, 0, ACCESS
1232  0648     DECF 0x48, F, ACCESS
323:                   dbuf[i] = s ? '-' : '+';
1234  503D     MOVF s, W, ACCESS
1236  103E     IORWF 0x3E, W, ACCESS
1238  E103     BNZ 0x1240
123A  6A38     CLRF 0x38, ACCESS
123C  0E2B     MOVLW 0x2B
123E  D002     BRA 0x1244
1240  6A38     CLRF 0x38, ACCESS
1242  0E2D     MOVLW 0x2D
1244  6E37     MOVWF 0x37, ACCESS
1246  D815     RCALL PL48
124A  F0DF     NOP
124C  FFDF     NOP
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
124E  C025     MOVFF fp, sign
1250  F01B     NOP
1252  C026     MOVFF 0x26, a
1254  F01C     NOP
1256  5047     MOVF i, W, ACCESS
1258  0F87     ADDLW 0x87
125A  6E1D     MOVWF buf, ACCESS
125C  C03B     MOVFF w, p
125E  F01E     NOP
1260  C03C     MOVFF 0x3C, 0x1F
1262  F01F     NOP
1264  EC72     CALL 0x1CE4, 0
1266  F00E     NOP
1268  C01B     MOVFF sign, fp
126A  F025     NOP
126C  C01C     MOVFF a, 0x26
126E  F026     NOP
328:           }
1270  0012     RETURN 0
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
15AE  EE20     LFSR 2, 0xE2
15B0  F0E2     NOP
15B2  EE10     LFSR 1, 0x1A
15B4  F01A     NOP
15B6  0E06     MOVLW 0x6
15BA  FF6F     NOP
15BC  FFE3     NOP
15BE  06E8     DECF 0xFE8, F, ACCESS
15C0  E2FB     BC 0x15B8
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
15C2  C017     MOVFF s, fp
15C4  F025     NOP
15C6  C018     MOVFF c, 0x26
15C8  F026     NOP
575:               if (!cp) {
15CA  5025     MOVF fp, W, ACCESS
15CC  1026     IORWF 0x26, W, ACCESS
15CE  E103     BNZ 0x15D6
576:                   cp = nuls;
15D0  0E1A     MOVLW 0x1A
15D2  6E25     MOVWF fp, ACCESS
15D4  6A26     CLRF 0x26, ACCESS
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
15D6  C025     MOVFF fp, dividend
15D8  F00A     NOP
15DA  C026     MOVFF 0x26, blue
15DC  F00B     NOP
15DE  ECC5     CALL 0x218A, 0
15E0  F010     NOP
15E2  C00A     MOVFF dividend, l
15E4  F029     NOP
15E6  C00B     MOVFF blue, 0x2A
15E8  F02A     NOP
581:               p = prec;
15EA  C07F     MOVFF prec, d
15EC  F027     NOP
15EE  C080     MOVFF 0x80, 0x28
15F0  F028     NOP
582:               l = (!(p < 0) && (p < l)) ? p : l;
15F2  BE28     BTFSC 0x28, 7, ACCESS
15F4  D00D     BRA 0x1610
15F6  5029     MOVF l, W, ACCESS
15F8  5C27     SUBWF d, W, ACCESS
15FA  5028     MOVF 0x28, W, ACCESS
15FC  0A80     XORLW 0x80
15FE  6E19     MOVWF i, ACCESS
1600  502A     MOVF 0x2A, W, ACCESS
1602  0A80     XORLW 0x80
1604  5819     SUBWFB i, W, ACCESS
1606  E204     BC 0x1610
1608  C027     MOVFF d, l
160A  F029     NOP
160C  C028     MOVFF 0x28, 0x2A
160E  F02A     NOP
583:               p = l;
1610  C029     MOVFF l, d
1612  F027     NOP
1614  C02A     MOVFF 0x2A, 0x28
1616  F028     NOP
584:               w = width;
1618  C07D     MOVFF width, w
161A  F023     NOP
161C  C07E     MOVFF 0x7E, 0x24
161E  F024     NOP
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
1620  B04E     BTFSC flags, 0, ACCESS
1622  D008     BRA 0x1634
1624  D005     BRA 0x1630
588:                   while (l < w) {
1630  D82F     RCALL PL22
1632  E3F9     BNC 0x1626
589:                       fputc(' ', fp);
1626  D83D     RCALL PL32
1628  EC28     CALL 0x1E50, 0
162A  F00F     NOP
590:                       ++l;
162C  4A29     INFSNZ l, F, ACCESS
162E  2A2A     INCF 0x2A, F, ACCESS
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
1634  6A21     CLRF i, ACCESS
1636  6A22     CLRF 0x22, ACCESS
596:               while (i < p) {
1638  D013     BRA 0x1660
1660  5027     MOVF d, W, ACCESS
1662  5C21     SUBWF i, W, ACCESS
1664  5022     MOVF 0x22, W, ACCESS
1666  0A80     XORLW 0x80
1668  6E19     MOVWF i, ACCESS
166A  5028     MOVF 0x28, W, ACCESS
166C  0A80     XORLW 0x80
166E  5819     SUBWFB i, W, ACCESS
1670  E3E4     BNC 0x163A
597:                   fputc(*cp, fp);
163C  F097     NOP
163E  FFD9     NOP
1642  F09B     NOP
1644  FFDA     NOP
1646  50DF     MOVF 0xFDF, W, ACCESS
1648  6E0C     MOVWF status, ACCESS
164A  6A0D     CLRF i, ACCESS
164C  C015     MOVFF fp, product
164E  F00E     NOP
1650  C016     MOVFF fp, duration
1652  F00F     NOP
1654  EC28     CALL 0x1E50, 0
1656  F00F     NOP
598:                   ++cp;
1658  4A25     INFSNZ fp, F, ACCESS
165A  2A26     INCF 0x26, F, ACCESS
599:                   ++i;
165C  4A21     INFSNZ i, F, ACCESS
165E  2A22     INCF 0x22, F, ACCESS
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
1672  A04E     BTFSS flags, 0, ACCESS
1674  D008     BRA 0x1686
1676  D005     BRA 0x1682
604:                   while (l < w) {
1682  D806     RCALL PL22
1684  E3F9     BNC 0x1678
605:                       fputc(' ', fp);
1678  D814     RCALL PL32
167A  EC28     CALL 0x1E50, 0
167C  F00F     NOP
606:                       ++l;
167E  4A29     INFSNZ l, F, ACCESS
1680  2A2A     INCF 0x2A, F, ACCESS
607:                   }
608:               }
609:           
610:               return l;
1686  C029     MOVFF l, fp
1688  F015     NOP
168A  C02A     MOVFF 0x2A, fp
168C  F016     NOP
611:           }
168E  0012     RETURN 0
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
652:                   flags &= ~ZERO_FLAG;
653:               }
654:               p = (0 < prec) ? prec : 1;
655:               w = width;
656:               if (flags & POUND_FLAG) {
657:                   w -= 2;
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
662:               i = sizeof(dbuf) - 1;
663:               dbuf[i] = '\0';
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
665:                   --i;
666:                   c = n & 0x0f;
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
668:                   if (isupper((int)x) && isalpha(c)) {
669:                       c = toupper(c);
670:                   }
671:                   dbuf[i] = (char)c;
672:                   --p;
673:                   --w;
674:                   n = n >> 4;
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
679:                   --i;
680:                   dbuf[i] = x;
681:                   --i;
682:                   dbuf[i] = '0';
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
687:           }
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
127C  D8D7     RCALL PL2
127E  0A25     XORLW 0x25
1280  E001     BZ 0x1284
1282  D0CC     BRA 0x141C
703:                   ++*fmt;
1284  D8DF     RCALL __end_ofPL2
704:           
705:                   flags = width = 0;
1286  6B7D     CLRF width, BANKED
1288  6B7E     CLRF 0x7E, BANKED
128A  6A4E     CLRF flags, ACCESS
128C  6A4F     CLRF 0x4F, ACCESS
706:                   prec = -1;
128E  697F     SETF prec, BANKED
1290  6980     SETF 0x80, BANKED
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
1292  6BB5     CLRF done, BANKED
1294  6BB6     CLRF 0xB6, BANKED
711:                   while (!done) {
1296  D020     BRA 0x12D8
12D8  51B5     MOVF done, W, BANKED
12DA  11B6     IORWF 0xB6, W, BANKED
12DC  E0EC     BZ 0x12B6
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
1298  804E     BSF flags, 0, ACCESS
715:                               ++*fmt;
129A  D8D4     RCALL __end_ofPL2
716:                               break;
129C  D01D     BRA 0x12D8
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
129E  824E     BSF flags, 1, ACCESS
12A0  D7FC     BRA 0x129A
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
12A2  844E     BSF flags, 2, ACCESS
12A4  D7FA     BRA 0x129A
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
12A6  864E     BSF flags, 3, ACCESS
12A8  D7F8     BRA 0x129A
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
12AA  884E     BSF flags, 4, ACCESS
12AC  D7F6     BRA 0x129A
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
12AE  6BB6     CLRF 0xB6, BANKED
12B0  0E01     MOVLW 0x1
12B2  6FB5     MOVWF done, BANKED
735:                               break;
12B4  D011     BRA 0x12D8
736:                       }
12B6  D8BA     RCALL PL2
12B8  6FA7     MOVWF __pcstackBANK0, BANKED
12BA  6BA8     CLRF 0xA8, BANKED
12BC  51A8     MOVF 0xA8, W, BANKED
12BE  E1F7     BNZ 0x12AE
12C0  51A7     MOVF __pcstackBANK0, W, BANKED
12C2  0A20     XORLW 0x20
12C4  E0F0     BZ 0x12A6
12C6  0A03     XORLW 0x3
12C8  E0F0     BZ 0x12AA
12CA  0A08     XORLW 0x8
12CC  E0EA     BZ 0x12A2
12CE  0A06     XORLW 0x6
12D0  E0E3     BZ 0x1298
12D2  0A1D     XORLW 0x1D
12D4  E0E4     BZ 0x129E
12D6  D7EB     BRA 0x12AE
737:                   }
738:                   if (flags & MINUS_FLAG) {
12DE  B04E     BTFSC flags, 0, ACCESS
739:                       flags &= ~ZERO_FLAG;
12E0  924E     BCF flags, 1, ACCESS
12E2  D8A4     RCALL PL2
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
12E4  0A2A     XORLW 0x2A
12E6  E110     BNZ 0x1308
12E8  D8AD     RCALL __end_ofPL2
746:                       ++*fmt;
747:                       width = va_arg(ap, int);
12EA  D8B1     RCALL PL24
12EE  FF78     NOP
12F0  F07D     NOP
12F4  FF78     NOP
12F6  F07E     NOP
748:                       if (width < 0) {
12F8  AF7E     BTFSS 0x7E, 7, BANKED
12FA  D02B     BRA 0x1352
749:                           flags |= MINUS_FLAG;
12FC  804E     BSF flags, 0, ACCESS
750:                           width = -width;
12FE  6D7D     NEGF width, BANKED
1300  1F7E     COMF 0x7E, F, BANKED
1302  B0D8     BTFSC 0xFD8, 0, ACCESS
1304  2B7E     INCF 0x7E, F, BANKED
1306  D025     BRA 0x1352
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
1308  504B     MOVF fmt, W, ACCESS
130A  6ED9     MOVWF 0xFD9, ACCESS
130C  6ADA     CLRF 0xFDA, ACCESS
130E  50DF     MOVF 0xFDF, W, ACCESS
1310  6E11     MOVWF s, ACCESS
1312  ECDA     CALL 0x17B4, 0
1314  F00B     NOP
1316  C011     MOVFF s, width
1318  F07D     NOP
131A  C012     MOVFF divisor, 0x7E
131C  F07E     NOP
754:                       while (isdigit((*fmt)[0])) {
131E  D001     BRA 0x1322
1322  0ED0     MOVLW 0xD0
1324  0100     MOVLB 0x0
1326  6FA7     MOVWF __pcstackBANK0, BANKED
1328  69A8     SETF 0xA8, BANKED
132A  D880     RCALL PL2
132C  6FA9     MOVWF 0xA9, BANKED
132E  6BAA     CLRF 0xAA, BANKED
1330  51A7     MOVF __pcstackBANK0, W, BANKED
1332  27A9     ADDWF 0xA9, F, BANKED
1334  51A8     MOVF 0xA8, W, BANKED
1336  23AA     ADDWFC 0xAA, F, BANKED
1338  51AA     MOVF 0xAA, W, BANKED
133A  E105     BNZ 0x1346
133C  0E0A     MOVLW 0xA
133E  5DA9     SUBWF 0xA9, W, BANKED
1340  E202     BC 0x1346
1342  0E01     MOVLW 0x1
1344  D001     BRA 0x1348
1346  0E00     MOVLW 0x0
1348  6FB7     MOVWF 0xB7, BANKED
134A  6BB8     CLRF 0xB8, BANKED
134C  51B7     MOVF 0xB7, W, BANKED
134E  11B8     IORWF 0xB8, W, BANKED
1350  E1E7     BNZ 0x1320
1352  D86C     RCALL PL2
755:                           ++*fmt;
1320  D891     RCALL __end_ofPL2
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
1354  0A64     XORLW 0x64
1356  E003     BZ 0x135E
1358  D869     RCALL PL2
135A  0A69     XORLW 0x69
135C  E133     BNZ 0x13C4
135E  D872     RCALL __end_ofPL2
848:           
849:                       ++*fmt;
850:                       ll = (long long)va_arg(ap, int);
1360  504C     MOVF ap, W, ACCESS
1362  6ED9     MOVWF 0xFD9, ACCESS
1364  6ADA     CLRF 0xFDA, ACCESS
1366  50DF     MOVF 0xFDF, W, ACCESS
1368  2ADF     INCF 0xFDF, F, ACCESS
136A  2ADF     INCF 0xFDF, F, ACCESS
136C  6ED9     MOVWF 0xFD9, ACCESS
136E  6ADA     CLRF 0xFDA, ACCESS
1372  FF78     NOP
1374  F0AB     NOP
1378  FF74     NOP
137A  F0AC     NOP
137C  0E00     MOVLW 0x0
137E  BFAC     BTFSC 0xAC, 7, BANKED
1380  0EFF     MOVLW 0xFF
1382  6FAD     MOVWF 0xAD, BANKED
1384  6FAE     MOVWF 0xAE, BANKED
1386  6FAF     MOVWF 0xAF, BANKED
1388  6FB0     MOVWF 0xB0, BANKED
138A  6FB1     MOVWF 0xB1, BANKED
138C  6FB2     MOVWF 0xB2, BANKED
851:                                   
852:                       return dtoa(fp, ll);
138E  C049     MOVFF fp, fp
1390  F025     NOP
1392  C04A     MOVFF 0x4A, 0x26
1394  F026     NOP
1396  C0AB     MOVFF ll, d
1398  F027     NOP
139A  C0AC     MOVFF 0xAC, 0x28
139C  F028     NOP
139E  C0AD     MOVFF 0xAD, l
13A0  F029     NOP
13A2  C0AE     MOVFF 0xAE, 0x2A
13A4  F02A     NOP
13A6  C0AF     MOVFF 0xAF, 0x2B
13A8  F02B     NOP
13AA  C0B0     MOVFF 0xB0, 0x2C
13AC  F02C     NOP
13AE  C0B1     MOVFF 0xB1, 0x2D
13B0  F02D     NOP
13B2  C0B2     MOVFF 0xB2, 0x2E
13B4  F02E     NOP
13B6  EC43     CALL 0x1086, 0
13B8  F008     NOP
13BA  C025     MOVFF fp, fp
13BC  F049     NOP
13BE  C026     MOVFF 0x26, 0x4A
13C0  F04A     NOP
13C2  0012     RETURN 0
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
1100:                      ++*fmt;
1101:                      vp = (void *)va_arg(ap, int *);
1102:                      *(int *)vp = nout;
1103:                      return 0;
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
13C4  D833     RCALL PL2
13C6  0A73     XORLW 0x73
13C8  E117     BNZ 0x13F8
13CA  D83C     RCALL __end_ofPL2
13CC  D840     RCALL PL24
1172:          
1173:                      ++*fmt;
1174:                      cp = va_arg(ap, char *);
13D0  FF78     NOP
13D2  F0B3     NOP
13D6  FF78     NOP
13D8  F0B4     NOP
1175:          
1176:                      return stoa(fp, cp);
13DA  C049     MOVFF fp, fp
13DC  F015     NOP
13DE  C04A     MOVFF 0x4A, fp
13E0  F016     NOP
13E2  C0B3     MOVFF cp, s
13E4  F017     NOP
13E6  C0B4     MOVFF 0xB4, c
13E8  F018     NOP
13EA  ECD7     CALL 0x15AE, 0
13EC  F00A     NOP
13EE  C015     MOVFF fp, fp
13F0  F049     NOP
13F2  C016     MOVFF fp, 0x4A
13F4  F04A     NOP
13F6  0012     RETURN 0
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1297:          
1298:                      c = (*fmt)[0];
1299:                      ++*fmt;
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1301:                                  
1302:                      return xtoa(fp, llu, c);
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
13F8  D819     RCALL PL2
13FA  0A25     XORLW 0x25
13FC  E10B     BNZ 0x1414
13FE  D822     RCALL __end_ofPL2
1373:                      ++*fmt;
1374:                      fputc((int)'%', fp);
1400  6A0D     CLRF i, ACCESS
1402  0E25     MOVLW 0x25
1404  6E0C     MOVWF status, ACCESS
1406  D82C     RCALL PL44
1408  EC28     CALL 0x1E50, 0
140A  F00F     NOP
1375:                      return 1;
140C  6A4A     CLRF 0x4A, ACCESS
140E  0E01     MOVLW 0x1
1410  6E49     MOVWF fp, ACCESS
1412  0C01     RETLW 0x1
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
1414  D817     RCALL __end_ofPL2
1380:                  return 0;
1416  6A49     CLRF fp, ACCESS
1418  6A4A     CLRF 0x4A, ACCESS
141A  0012     RETURN 0
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
141C  D807     RCALL PL2
141E  6E0C     MOVWF status, ACCESS
1420  6A0D     CLRF i, ACCESS
1422  D81E     RCALL PL44
1424  EC28     CALL 0x1E50, 0
1426  F00F     NOP
1428  D80D     RCALL __end_ofPL2
1385:              ++*fmt;
142A  D7F0     BRA 0x140C
1386:              return 1;
1387:          }
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
1FA2  C0BB     MOVFF fmt, cfmt
1FA4  F04D     NOP
1396:              nout = 0;
1FA6  6B7B     CLRF nout, BANKED
1FA8  6B7C     CLRF 0x7C, BANKED
1397:              while (*cfmt) {
1FAA  D00F     BRA 0x1FCA
1FCC  F137     NOP
1FCE  FFF6     NOP
1FD0  EC45     CALL 0x188A, 0
1FD2  F00C     NOP
1FD4  E1EB     BNZ 0x1FAC
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1FAC  C0B9     MOVFF fp, fp
1FAE  F049     NOP
1FB0  C0BA     MOVFF 0xBA, 0x4A
1FB2  F04A     NOP
1FB4  0E4D     MOVLW 0x4D
1FB6  6E4B     MOVWF fmt, ACCESS
1FB8  C0BC     MOVFF ap, ap
1FBA  F04C     NOP
1FBC  EC3E     CALL 0x127C, 0
1FBE  F009     NOP
1FC0  5049     MOVF fp, W, ACCESS
1FC2  0100     MOVLB 0x0
1FC4  277B     ADDWF nout, F, BANKED
1FC6  504A     MOVF 0x4A, W, ACCESS
1FC8  237C     ADDWFC 0x7C, F, BANKED
1399:              }
1400:              return nout;
1FD6  C07B     MOVFF nout, fp
1FD8  F0B9     NOP
1FDA  C07C     MOVFF 0x7C, 0xBA
1FDC  F0BA     NOP
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
1FDE  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/atoi.c  --------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
17B4  6A1E     CLRF p, ACCESS
17B6  6A1F     CLRF 0x1F, ACCESS
17B8  6A17     CLRF s, ACCESS
17BA  6A18     CLRF c, ACCESS
7:             	while (isspace(*s)) s++;
17BC  D001     BRA 0x17C0
17BE  2A11     INCF s, F, ACCESS
17C0  0E01     MOVLW 0x1
17C2  6E1D     MOVWF buf, ACCESS
17C4  D868     RCALL __end_ofPL4
17C6  D861     RCALL PL4
17C8  0A20     XORLW 0x20
17CA  E00B     BZ 0x17E2
17CC  0EF7     MOVLW 0xF7
17CE  6E13     MOVWF 0x13, ACCESS
17D0  6814     SETF 0x14, ACCESS
17D2  D861     RCALL __end_ofPL4
17D4  D85A     RCALL PL4
17D6  D863     RCALL PL30
17D8  E103     BNZ 0x17E0
17DA  0E05     MOVLW 0x5
17DC  5C15     SUBWF fp, W, ACCESS
17DE  E301     BNC 0x17E2
17E0  6A1D     CLRF buf, ACCESS
17E2  C01D     MOVFF buf, i
17E4  F019     NOP
17E6  6A1A     CLRF counter, ACCESS
17E8  5019     MOVF i, W, ACCESS
17EA  101A     IORWF counter, W, ACCESS
17EC  E006     BZ 0x17FA
17EE  D7E7     BRA 0x17BE
8:             	switch (*s) {
9:             	case '-': neg=1;
17F0  6A18     CLRF c, ACCESS
17F2  0E01     MOVLW 0x1
17F4  6E17     MOVWF s, ACCESS
10:            	case '+': s++;
17F6  2A11     INCF s, F, ACCESS
11:            	}
17F8  D021     BRA 0x183C
17FA  D84D     RCALL __end_ofPL4
17FC  D846     RCALL PL4
17FE  6E13     MOVWF 0x13, ACCESS
1800  6A14     CLRF 0x14, ACCESS
1802  5014     MOVF 0x14, W, ACCESS
1804  E11B     BNZ 0x183C
1806  5013     MOVF 0x13, W, ACCESS
1808  0A2B     XORLW 0x2B
180A  E0F5     BZ 0x17F6
180C  0A06     XORLW 0x6
180E  E0F0     BZ 0x17F0
1810  D015     BRA 0x183C
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
183C  0ED0     MOVLW 0xD0
183E  6E13     MOVWF 0x13, ACCESS
1840  6814     SETF 0x14, ACCESS
1842  D829     RCALL __end_ofPL4
1844  D822     RCALL PL4
1846  D82B     RCALL PL30
1848  E105     BNZ 0x1854
184A  0E0A     MOVLW 0xA
184C  5C15     SUBWF fp, W, ACCESS
184E  E202     BC 0x1854
1850  0E01     MOVLW 0x1
1852  D001     BRA 0x1856
1854  0E00     MOVLW 0x0
1856  6E1B     MOVWF sign, ACCESS
1858  6A1C     CLRF a, ACCESS
185A  501B     MOVF sign, W, ACCESS
185C  101C     IORWF a, W, ACCESS
185E  E1D9     BNZ 0x1812
14:            		n = 10*n - (int)(*s++ - '0');
1812  C01E     MOVFF p, dividend
1814  F00A     NOP
1816  C01F     MOVFF 0x1F, blue
1818  F00B     NOP
181A  6A0D     CLRF i, ACCESS
181C  0E0A     MOVLW 0xA
181E  6E0C     MOVWF status, ACCESS
1820  ECF1     CALL 0x21E2, 0
1822  F010     NOP
1824  D838     RCALL __end_ofPL4
1826  D831     RCALL PL4
1828  5E0A     SUBWF dividend, F, ACCESS
182A  0E00     MOVLW 0x0
182C  5A0B     SUBWFB blue, F, ACCESS
182E  0E30     MOVLW 0x30
1830  240A     ADDWF dividend, W, ACCESS
1832  6E1E     MOVWF p, ACCESS
1834  0E00     MOVLW 0x0
1836  200B     ADDWFC blue, W, ACCESS
1838  6E1F     MOVWF 0x1F, ACCESS
183A  D7DD     BRA 0x17F6
15:            	return neg ? n : -n;
1860  5017     MOVF s, W, ACCESS
1862  1018     IORWF c, W, ACCESS
1864  E10D     BNZ 0x1880
1866  C01E     MOVFF p, 0x13
1868  F013     NOP
186A  C01F     MOVFF 0x1F, 0x14
186C  F014     NOP
186E  1E13     COMF 0x13, F, ACCESS
1870  1E14     COMF 0x14, F, ACCESS
1872  4A13     INFSNZ 0x13, F, ACCESS
1874  2A14     INCF 0x14, F, ACCESS
1876  C013     MOVFF 0x13, s
1878  F011     NOP
187A  C014     MOVFF 0x14, divisor
187C  F012     NOP
187E  0012     RETURN 0
1880  C01E     MOVFF p, s
1882  F011     NOP
1884  C01F     MOVFF 0x1F, divisor
1886  F012     NOP
16:            }
1888  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/aomod.c  -------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
16B2  6A1B     CLRF sign, ACCESS
15:            	if(dividend < 0) {
16B4  AE11     BTFSS s, 7, ACCESS
16B6  D003     BRA 0x16BE
16:            		dividend = -dividend;
16B8  D86C     RCALL __end_of___aomod
17:            		sign = 1;
16BA  0E01     MOVLW 0x1
16BC  6E1B     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
16BE  AE19     BTFSS i, 7, ACCESS
16C0  D010     BRA 0x16E2
20:            		divisor = -divisor;
16C2  1E19     COMF i, F, ACCESS
16C4  1E18     COMF c, F, ACCESS
16C6  1E17     COMF s, F, ACCESS
16C8  1E16     COMF fp, F, ACCESS
16CA  1E15     COMF fp, F, ACCESS
16CC  1E14     COMF 0x14, F, ACCESS
16CE  1E13     COMF 0x13, F, ACCESS
16D0  6C12     NEGF divisor, ACCESS
16D2  0E00     MOVLW 0x0
16D4  2213     ADDWFC 0x13, F, ACCESS
16D6  2214     ADDWFC 0x14, F, ACCESS
16D8  2215     ADDWFC fp, F, ACCESS
16DA  2216     ADDWFC fp, F, ACCESS
16DC  2217     ADDWFC s, F, ACCESS
16DE  2218     ADDWFC c, F, ACCESS
16E0  2219     ADDWFC i, F, ACCESS
21:            	if(divisor != 0) {
16E2  5012     MOVF divisor, W, ACCESS
16E4  1013     IORWF 0x13, W, ACCESS
16E6  1014     IORWF 0x14, W, ACCESS
16E8  1015     IORWF fp, W, ACCESS
16EA  1016     IORWF fp, W, ACCESS
16EC  1017     IORWF s, W, ACCESS
16EE  1018     IORWF c, W, ACCESS
16F0  1019     IORWF i, W, ACCESS
16F2  E03B     BZ 0x176A
22:            		counter = 1;
16F4  0E01     MOVLW 0x1
16F6  6E1A     MOVWF counter, ACCESS
23:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
16F8  D00A     BRA 0x170E
170E  AE19     BTFSS i, 7, ACCESS
1710  D7F4     BRA 0x16FA
24:            			divisor <<= 1;
16FA  90D8     BCF 0xFD8, 0, ACCESS
16FC  3612     RLCF divisor, F, ACCESS
16FE  3613     RLCF 0x13, F, ACCESS
1700  3614     RLCF 0x14, F, ACCESS
1702  3615     RLCF fp, F, ACCESS
1704  3616     RLCF fp, F, ACCESS
1706  3617     RLCF s, F, ACCESS
1708  3618     RLCF c, F, ACCESS
170A  3619     RLCF i, F, ACCESS
25:            			counter++;
170C  2A1A     INCF counter, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
1712  5012     MOVF divisor, W, ACCESS
1714  5C0A     SUBWF dividend, W, ACCESS
1716  5013     MOVF 0x13, W, ACCESS
1718  580B     SUBWFB blue, W, ACCESS
171A  5014     MOVF 0x14, W, ACCESS
171C  580C     SUBWFB status, W, ACCESS
171E  5015     MOVF fp, W, ACCESS
1720  580D     SUBWFB i, W, ACCESS
1722  5016     MOVF fp, W, ACCESS
1724  580E     SUBWFB product, W, ACCESS
1726  5017     MOVF s, W, ACCESS
1728  580F     SUBWFB duration, W, ACCESS
172A  5018     MOVF c, W, ACCESS
172C  5810     SUBWFB j, W, ACCESS
172E  5019     MOVF i, W, ACCESS
1730  5811     SUBWFB s, W, ACCESS
1732  E310     BNC 0x1754
29:            				dividend -= divisor;
1734  5012     MOVF divisor, W, ACCESS
1736  5E0A     SUBWF dividend, F, ACCESS
1738  5013     MOVF 0x13, W, ACCESS
173A  5A0B     SUBWFB blue, F, ACCESS
173C  5014     MOVF 0x14, W, ACCESS
173E  5A0C     SUBWFB status, F, ACCESS
1740  5015     MOVF fp, W, ACCESS
1742  5A0D     SUBWFB i, F, ACCESS
1744  5016     MOVF fp, W, ACCESS
1746  5A0E     SUBWFB product, F, ACCESS
1748  5017     MOVF s, W, ACCESS
174A  5A0F     SUBWFB duration, F, ACCESS
174C  5018     MOVF c, W, ACCESS
174E  5A10     SUBWFB j, F, ACCESS
1750  5019     MOVF i, W, ACCESS
1752  5A11     SUBWFB s, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
1754  90D8     BCF 0xFD8, 0, ACCESS
1756  3219     RRCF i, F, ACCESS
1758  3218     RRCF c, F, ACCESS
175A  3217     RRCF s, F, ACCESS
175C  3216     RRCF fp, F, ACCESS
175E  3215     RRCF fp, F, ACCESS
1760  3214     RRCF 0x14, F, ACCESS
1762  3213     RRCF 0x13, F, ACCESS
1764  3212     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
1766  2E1A     DECFSZ counter, F, ACCESS
1768  D7D4     BRA 0x1712
32:            	}
33:            	if(sign)
176A  501B     MOVF sign, W, ACCESS
176C  E001     BZ 0x1770
176E  D811     RCALL __end_of___aomod
34:            		dividend = -dividend;
35:            	return dividend;
1770  C00A     MOVFF dividend, dividend
1772  F00A     NOP
1774  C00B     MOVFF blue, blue
1776  F00B     NOP
1778  C00C     MOVFF status, status
177A  F00C     NOP
177C  C00D     MOVFF i, i
177E  F00D     NOP
1780  C00E     MOVFF product, product
1782  F00E     NOP
1784  C00F     MOVFF duration, duration
1786  F00F     NOP
1788  C010     MOVFF j, j
178A  F010     NOP
178C  C011     MOVFF s, s
178E  F011     NOP
36:            }
1790  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/aodiv.c  -------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
146A  6A1B     CLRF sign, ACCESS
16:            	if(divisor < 0) {
146C  AE19     BTFSS i, 7, ACCESS
146E  D012     BRA 0x1494
17:            		divisor = -divisor;
1470  1E19     COMF i, F, ACCESS
1472  1E18     COMF c, F, ACCESS
1474  1E17     COMF s, F, ACCESS
1476  1E16     COMF fp, F, ACCESS
1478  1E15     COMF fp, F, ACCESS
147A  1E14     COMF 0x14, F, ACCESS
147C  1E13     COMF 0x13, F, ACCESS
147E  6C12     NEGF divisor, ACCESS
1480  0E00     MOVLW 0x0
1482  2213     ADDWFC 0x13, F, ACCESS
1484  2214     ADDWFC 0x14, F, ACCESS
1486  2215     ADDWFC fp, F, ACCESS
1488  2216     ADDWFC fp, F, ACCESS
148A  2217     ADDWFC s, F, ACCESS
148C  2218     ADDWFC c, F, ACCESS
148E  2219     ADDWFC i, F, ACCESS
18:            		sign = 1;
1490  0E01     MOVLW 0x1
1492  6E1B     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
1494  AE11     BTFSS s, 7, ACCESS
1496  D012     BRA 0x14BC
21:            		dividend = -dividend;
1498  1E11     COMF s, F, ACCESS
149A  1E10     COMF j, F, ACCESS
149C  1E0F     COMF duration, F, ACCESS
149E  1E0E     COMF product, F, ACCESS
14A0  1E0D     COMF i, F, ACCESS
14A2  1E0C     COMF status, F, ACCESS
14A4  1E0B     COMF blue, F, ACCESS
14A6  6C0A     NEGF dividend, ACCESS
14A8  0E00     MOVLW 0x0
14AA  220B     ADDWFC blue, F, ACCESS
14AC  220C     ADDWFC status, F, ACCESS
14AE  220D     ADDWFC i, F, ACCESS
14B0  220E     ADDWFC product, F, ACCESS
14B2  220F     ADDWFC duration, F, ACCESS
14B4  2210     ADDWFC j, F, ACCESS
14B6  2211     ADDWFC s, F, ACCESS
22:            		sign ^= 1;
14B8  0E01     MOVLW 0x1
14BA  1A1B     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
14BC  6A1C     CLRF a, ACCESS
14BE  6A1D     CLRF buf, ACCESS
14C0  6A1E     CLRF p, ACCESS
14C2  6A1F     CLRF 0x1F, ACCESS
14C4  6A20     CLRF 0x20, ACCESS
14C6  6A21     CLRF i, ACCESS
14C8  6A22     CLRF 0x22, ACCESS
14CA  6A23     CLRF w, ACCESS
25:            	if(divisor != 0) {
14CC  5012     MOVF divisor, W, ACCESS
14CE  1013     IORWF 0x13, W, ACCESS
14D0  1014     IORWF 0x14, W, ACCESS
14D2  1015     IORWF fp, W, ACCESS
14D4  1016     IORWF fp, W, ACCESS
14D6  1017     IORWF s, W, ACCESS
14D8  1018     IORWF c, W, ACCESS
14DA  1019     IORWF i, W, ACCESS
14DC  E045     BZ 0x1568
26:            		counter = 1;
14DE  0E01     MOVLW 0x1
14E0  6E1A     MOVWF counter, ACCESS
27:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
14E2  D00A     BRA 0x14F8
14F8  AE19     BTFSS i, 7, ACCESS
14FA  D7F4     BRA 0x14E4
28:            			divisor <<= 1;
14E4  90D8     BCF 0xFD8, 0, ACCESS
14E6  3612     RLCF divisor, F, ACCESS
14E8  3613     RLCF 0x13, F, ACCESS
14EA  3614     RLCF 0x14, F, ACCESS
14EC  3615     RLCF fp, F, ACCESS
14EE  3616     RLCF fp, F, ACCESS
14F0  3617     RLCF s, F, ACCESS
14F2  3618     RLCF c, F, ACCESS
14F4  3619     RLCF i, F, ACCESS
29:            			counter++;
14F6  2A1A     INCF counter, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
14FC  90D8     BCF 0xFD8, 0, ACCESS
14FE  361C     RLCF a, F, ACCESS
1500  361D     RLCF buf, F, ACCESS
1502  361E     RLCF p, F, ACCESS
1504  361F     RLCF 0x1F, F, ACCESS
1506  3620     RLCF 0x20, F, ACCESS
1508  3621     RLCF i, F, ACCESS
150A  3622     RLCF 0x22, F, ACCESS
150C  3623     RLCF w, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
150E  5012     MOVF divisor, W, ACCESS
1510  5C0A     SUBWF dividend, W, ACCESS
1512  5013     MOVF 0x13, W, ACCESS
1514  580B     SUBWFB blue, W, ACCESS
1516  5014     MOVF 0x14, W, ACCESS
1518  580C     SUBWFB status, W, ACCESS
151A  5015     MOVF fp, W, ACCESS
151C  580D     SUBWFB i, W, ACCESS
151E  5016     MOVF fp, W, ACCESS
1520  580E     SUBWFB product, W, ACCESS
1522  5017     MOVF s, W, ACCESS
1524  580F     SUBWFB duration, W, ACCESS
1526  5018     MOVF c, W, ACCESS
1528  5810     SUBWFB j, W, ACCESS
152A  5019     MOVF i, W, ACCESS
152C  5811     SUBWFB s, W, ACCESS
152E  E311     BNC 0x1552
34:            				dividend -= divisor;
1530  5012     MOVF divisor, W, ACCESS
1532  5E0A     SUBWF dividend, F, ACCESS
1534  5013     MOVF 0x13, W, ACCESS
1536  5A0B     SUBWFB blue, F, ACCESS
1538  5014     MOVF 0x14, W, ACCESS
153A  5A0C     SUBWFB status, F, ACCESS
153C  5015     MOVF fp, W, ACCESS
153E  5A0D     SUBWFB i, F, ACCESS
1540  5016     MOVF fp, W, ACCESS
1542  5A0E     SUBWFB product, F, ACCESS
1544  5017     MOVF s, W, ACCESS
1546  5A0F     SUBWFB duration, F, ACCESS
1548  5018     MOVF c, W, ACCESS
154A  5A10     SUBWFB j, F, ACCESS
154C  5019     MOVF i, W, ACCESS
154E  5A11     SUBWFB s, F, ACCESS
35:            				quotient |= 1;
1550  801C     BSF a, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
1552  90D8     BCF 0xFD8, 0, ACCESS
1554  3219     RRCF i, F, ACCESS
1556  3218     RRCF c, F, ACCESS
1558  3217     RRCF s, F, ACCESS
155A  3216     RRCF fp, F, ACCESS
155C  3215     RRCF fp, F, ACCESS
155E  3214     RRCF 0x14, F, ACCESS
1560  3213     RRCF 0x13, F, ACCESS
1562  3212     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
1564  2E1A     DECFSZ counter, F, ACCESS
1566  D7CA     BRA 0x14FC
39:            	}
40:            	if(sign)
1568  501B     MOVF sign, W, ACCESS
156A  E010     BZ 0x158C
41:            		quotient = -quotient;
156C  1E23     COMF w, F, ACCESS
156E  1E22     COMF 0x22, F, ACCESS
1570  1E21     COMF i, F, ACCESS
1572  1E20     COMF 0x20, F, ACCESS
1574  1E1F     COMF 0x1F, F, ACCESS
1576  1E1E     COMF p, F, ACCESS
1578  1E1D     COMF buf, F, ACCESS
157A  6C1C     NEGF a, ACCESS
157C  0E00     MOVLW 0x0
157E  221D     ADDWFC buf, F, ACCESS
1580  221E     ADDWFC p, F, ACCESS
1582  221F     ADDWFC 0x1F, F, ACCESS
1584  2220     ADDWFC 0x20, F, ACCESS
1586  2221     ADDWFC i, F, ACCESS
1588  2222     ADDWFC 0x22, F, ACCESS
158A  2223     ADDWFC w, F, ACCESS
42:            	return quotient;
158C  C01C     MOVFF a, dividend
158E  F00A     NOP
1590  C01D     MOVFF buf, blue
1592  F00B     NOP
1594  C01E     MOVFF p, status
1596  F00C     NOP
1598  C01F     MOVFF 0x1F, i
159A  F00D     NOP
159C  C020     MOVFF 0x20, product
159E  F00E     NOP
15A0  C021     MOVFF i, duration
15A2  F00F     NOP
15A4  C022     MOVFF 0x22, j
15A6  F010     NOP
15A8  C023     MOVFF w, s
15AA  F011     NOP
43:            }
15AC  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/abs.c  ---------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
212C  BE1D     BTFSC buf, 7, ACCESS
212E  D004     BRA 0x2138
2130  501D     MOVF buf, W, ACCESS
2132  E10F     BNZ 0x2152
2134  041C     DECF a, W, ACCESS
2136  E20D     BC 0x2152
2138  C01C     MOVFF a, p
213A  F01E     NOP
213C  C01D     MOVFF buf, 0x1F
213E  F01F     NOP
2140  1E1E     COMF p, F, ACCESS
2142  1E1F     COMF 0x1F, F, ACCESS
2144  4A1E     INFSNZ p, F, ACCESS
2146  2A1F     INCF 0x1F, F, ACCESS
2148  C01E     MOVFF p, a
214A  F01C     NOP
214C  C01F     MOVFF 0x1F, buf
214E  F01D     NOP
2150  0012     RETURN 0
2152  C01C     MOVFF a, a
2154  F01C     NOP
2156  C01D     MOVFF buf, buf
2158  F01D     NOP
4:             }
215A  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/Umul16.c  ------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
21E2  500A     MOVF dividend, W, ACCESS
21E4  020C     MULWF status, ACCESS
21E8  FFCC     NOP
21EA  F00E     NOP
21EE  FFD0     NOP
21F0  F00F     NOP
38:                    product += (unsigned int)(LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
21F2  500A     MOVF dividend, W, ACCESS
21F4  020D     MULWF i, ACCESS
21F6  50F3     MOVF 0xFF3, W, ACCESS
21F8  260F     ADDWF duration, F, ACCESS
39:                    product += (unsigned int)(HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
21FA  500B     MOVF blue, W, ACCESS
21FC  020C     MULWF status, ACCESS
21FE  50F3     MOVF 0xFF3, W, ACCESS
2200  260F     ADDWF duration, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
2202  C00E     MOVFF product, dividend
2204  F00A     NOP
2206  C00F     MOVFF duration, blue
2208  F00B     NOP
53:            }
220A  0012     RETURN 0
